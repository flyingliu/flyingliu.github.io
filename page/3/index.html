<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="依法不依人，依义不依语。">
<meta property="og:type" content="website">
<meta property="og:title" content="如是我闻">
<meta property="og:url" content="http://flyingliu.github.io/page/3/index.html">
<meta property="og:site_name" content="如是我闻">
<meta property="og:description" content="依法不依人，依义不依语。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="如是我闻">
<meta name="twitter:description" content="依法不依人，依义不依语。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://flyingliu.github.io/page/3/"/>





  <title>如是我闻</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">如是我闻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">色即是空，空即是色</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2016/04/03/2016-04-02-js-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/03/2016-04-02-js-function/" itemprop="url">JS中特殊的对象——函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-03T20:12:18+08:00">
                2016-04-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/04/03/2016-04-02-js-function/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/04/03/2016-04-02-js-function/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于函数是对象，继承自object，因此函数名实际上是一个指向函数对象的指针。</p>
<p>使用函数声明的语法定义：</p>
<pre><code>function sum(num1,num2)
{
    return num1+num2;
}
</code></pre><p>这种声明方法，使得sum的类型为function型。</p>
<p>使用函数表达式定义函数：</p>
<pre><code>var sum=function(num1,num2){
    return num1+num2;
}
</code></pre><p>这种方法，定义了变量sum并将其初始化为一个函数。通过变量sum就可以引用函数，这样可以通过变量将函数赋值给其他变量使用这一个函数。不用再声明同功能的函数了。</p>
<p>使用Function构造函数:</p>
<pre><code>var sum=new  Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;);
</code></pre><p>不推荐，这种语法会导致解析两次代码。一次是常规代码，依次是字符串。</p>
<p>【补充】说一下，第二种方法，由于函数名仅仅是指向函数的指针，所以一个函数可能会有多个名字。</p>
<pre><code>var anothersum=sum;
sum=null;
var s=anothersum(1,2);//3
</code></pre><p>当sum后面不带括号的时候，是赋值，即让anothersum也指向该函数实例。而当将sum置空，即sum不指向该函数实例，我们发现也完全不影响anothersum指向。</p>
<p>function没有重载</p>
<p>重载是指将函数设置不同的参数个数或类型，当实际调用函数时，根据参数的个数或类型来选择适合的函数。（我说的白话）</p>
<p>原因</p>
<p>函数名想象为指针后，</p>
<pre><code>function sum(num1,num2)
{
    return num1+num2;//+
}
var sum=function(num1,num2){
    return num1-num2;//-
};
alert(sum(1,2));//-1
</code></pre><p>发现第二个函数覆盖了第一个函数，原因是因为sum被指向了另一个实例化的函数对象。</p>
<p>弥补</p>
<p>当程序想要通过根据参数的个数实现重载时，我们可以借助函数的内部属性：arguments</p>
<p>在函数内部有两个而特殊的对象，this与arguments。</p>
<p>arguments与函数的参数有关，js函数的参数与其他语言中函数的参数有所不同，js不介意传递进来多少个参数，也不在乎传进来的参数是什么数据类型，这样一听，貌似重载没得救了，因为似乎无论形参设置多少个，都没关系，调用该函数时肯定会调用他。而实参传递多少似乎函数都可以获得，这就要通过arguments啦.</p>
<p>arguments其主要用途是用来保存函数参数。</p>
<pre><code>arguments[0]//表示传递的第一个元素
arguments[1]//表示传递的第二个元素
 ……//与数组类似，但是并不是Array的实例哦
</code></pre><p>可以通过 arguments.length的值来判断实参的个数。进而可以通过if语句来判断语句的执行情况。</p>
<p>需要注意的是，即使形参可有可无，但是，既然提供了这个功能，那么他必然和arguments之间有一定的关系，即二者之中哪一个被修改了，都会影响到对方的值，但是二者并不是指向同一个内存空间。</p>
<p>arguments这个对象还有一个属性：callee，该属性是一个指针，指向拥有arguments对象的函数。</p>
<p>这个属性有一个经典的作用：看这个函数</p>
<p>function factorial(num){<br>  if(num&lt;=1){<br>      return 1;<br>  }<br>  else{<br>      return num*factorial(num-1);<br>  }<br>}<br>alert(factorial(5));//120</p>
<p>这是一个计算阶乘的递归函数，发现函数内部使用了变量factorial，但是事实上一个实例化的函数对象可以拥有很多个名字，但是这样写似乎使得这个递归函数只能效力于名字是factorial的啦，</p>
<p>【解决方法】</p>
<pre><code>//将
return num*factorial(num-1);
//替换为
return num*arguments.callee(num-1);
</code></pre><p>this对象</p>
<p>函数内部的另一个特殊对象，</p>
<p>this是js的一个关键字，其的值会跟着环境的不同而不同。</p>
<p>但是有一个原则，this指的是调用函数的那个对象，更精准的this引用的是函数据以执行的环境对象。</p>
<p>当在网页全局作用域中调用时，this对象引用的就是window。</p>
<p>caller这个属性虽然在ECMAScript 3并没有定义这个属性，但是这个属性中保存着调用当前函数的函数的引用。</p>
<pre><code>function outer(){
  inner();
}
function inner(){
  alert(arguments.callee.caller)
}
outer()//显示outer函数的源代码
</code></pre><p>函数的属性和方法</p>
<p>除了前面提到的函数内部的两个特殊对象，在函数外部，我们还可以通过：函数名.函数的属性名或方法名的模式调用函数的属性和方法。</p>
<p>属性length</p>
<p>表示每个函数准备接收的命名参数的个数，即形参的个数，区别于内部对象arguments是实参的个数。</p>
<pre><code>function sum(num1,num2,num3)
{
   alert(arguments.callee.length);//方法2：内部对象调用
}
sum(1,2)
alert(sum.length);//方法1：函数调用
</code></pre><p>属性prototype</p>
<p>这个属性即为原型属性，在创建自定义类型及实现继承时，该属性的作用极为重要。</p>
<p>方法apply()与方法call()</p>
<p>这两个方法是非继承而来的，所以也就是鼻祖object对象可没有这两个方法。这两个方法的用途都是在特定的作用域中调用函数，实际上设置函数体内this对象的值。等等！this对象的值！</p>
<pre><code>var obj={name:&quot;dudu&quot;;}; 
var ss=function(){alert(this.name)};
obj.showname=ss;
</code></pre><p>此时ss所指向的函数内部的this的是obj。这个是我们常见的修改this对象值的方法。<br>js通过为函数提供这两个方法，也可以实现修改函数this对象的方法</p>
<p>apply方法 有两个参数，1个是在其中运行函数的作用域，另一个是参数数组。</p>
<pre><code>function sum(num1,num2)
{
    return num1+num2;
}
function callsum(num1,num2)
{
    return sum.apply(this,arguments);
    return sum.apply(this,[num1,num2]);//效果一样，数组！！
}
alert(callsum(10,10))//20
</code></pre><p>callsum里面的this，由于callsum是在全局作用域下被调用，所以this是windows对象，即为sum函数创造一个全局作用域。第二个参数是arguments，即callsum的参数，并将它作为sum 的参数。apply所在的那句代码翻译下来就是在全局环境下：sum（10,10）;</p>
<p>call方法，与apply方法的作用一样，但是接收参数的方式不同，其参数必须逐个例出来</p>
<pre><code>return sum.call(this,num1,num2);
</code></pre><p>以上这两个例子并没有看出来他们的作用，看下一个例子。</p>
<pre><code>/*定义一个属于两个对象的属性red*/
window.color=&apos;red&apos;;
var o={color:&quot;blue&quot;};
/*this的值取决于调用他的对象，*/
function sayColor(){
    alert(this.color);
}
/*将作用域设为this，即展示window.color*/
sayColor.call(this);//red
sayColor.call(window);//red
/*将作用域设为o，即展示o.color*/
sayColor.call(o);//blue
</code></pre><p>使用call()与apply()方法较之前设置this值的方法的好处是对象不需要与方法有任何的关系。上个例子，对象o并没有将saycolor设置为自己的方法，却也可以使用这个函数。</p>
<p>bind方法</p>
<pre><code>window.color=&apos;red&apos;;
var o={color:&quot;blue&quot;};
/*this的值取决于调用他的对象，*/
function sayColor(){
    alert(this.color);
var objectSayColor=sayColor.bind(o);
objectSayColor();//blue
</code></pre><p>新创建的函数objectSayColor其this值被绑定了对象o，即使在全局环境下运行，其this值也是对象o。</p>
<p>toString()、toLocalString()、valueOf()这三个也是函数的方法，但是其返回值均为函数的代码，至于代码格式因浏览而异。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2016/04/03/2016-04-02-js-new/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/03/2016-04-02-js-new/" itemprop="url">理解js中的new</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-03T17:09:34+08:00">
                2016-04-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/04/03/2016-04-02-js-new/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/04/03/2016-04-02-js-new/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果在一个函数前面带上new来调用该函数，那么将创建一个隐藏连接到该函数的prototype成员的新对象，同时this将被绑定到那个新对象上。</p>
<h3 id="new的过程"><a href="#new的过程" class="headerlink" title="new的过程"></a>new的过程</h3><pre><code>var Person = function(){};
var p = new Person();
</code></pre><p>new的过程拆分成以下三步：</p>
<ol>
<li>var p={}; 也就是说，初始化一个对象p</li>
<li>p.<strong>proto</strong> = Person.prototype;</li>
<li>Person.call(p); 也就是说构造p，也可以称之为初始化p</li>
</ol>
<h3 id="prototype和proto的概念"><a href="#prototype和proto的概念" class="headerlink" title="prototype和proto的概念"></a>prototype和<strong>proto</strong>的概念</h3><p>prototype是函数的内置属性，<strong>proto</strong>是对象的内置属性。</p>
<p>prototype是函数的一个属性，这个属性是一个指针，指向一个对象。它是显示修改对象的原型的属性。</p>
<p>上例子中：</p>
<pre><code>p.__proto__ === Person.prototype  // true
</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>var Person = function(){};
Person.prototype.sayName = function() {
    alert(&quot;My Name is Jacky&quot;);
};

Person.prototype.age = 27;
var p = new Person();
p.sayName();
</code></pre><p>p是一个引用指向Person的对象。我们在Person的原型上定义了一个sayName方法和age属性，当我们执行p.age时，会先在this的内部查找（也就是构造函数内部），如果没有找到然后再沿着原型链向上追溯。</p>
<p>这里的向上追溯是怎么向上的呢？这里就要使用<strong>proto</strong>属性来链接到原型（也就是Person.prototype）进行查找。最终在原型上找到了age属性。</p>
<ol>
<li><p>如果就一个函数，没有返回值，没有prototype成员，然后使用new,会是什么结果呢？如果一个函数没有返回值，那么如果不使用new来创建变量，那么该变量的值为undefined.如果用了new，那么就是Object.说明一个函数的默认的Prototype是Object.</p>
<p> function A(a) {<br>   this.a = a;<br>   this.b = b;<br> }<br> var a = new A(“abc”);<br> var b = A(“abc”);<br> console.log(a);   // abc<br> console.log(b);   // undefined</p>
</li>
</ol>
<ol start="2">
<li><p>如果函数有返回值，但是返回值是基本类型。那么new出来的a1还是object.因为基本类型的prototype还是Object. 而如果不使用new，那么返回值就是string的值。</p>
<p> function B(a) {<br>   this.a = a;<br>   return this.a<br> }<br> var a1 = new B(“abc”);<br> var b1 = B(“abc”);<br> console.log(a1);  // {a: “abc”}<br> console.log(b1);  // abc</p>
</li>
<li><p>如果函数的返回值为new出来的对象，那么c1的值根据new出来的对象的prototype而定。</p>
<p> function C(a) {</p>
<pre><code>this.a = a;
return new String(this.a);
</code></pre><p> }<br> var c1 = new C(“test”);<br> console.log(c1); // object</p>
</li>
<li><p>接下来我们开始讨论new中的this。如果我们给E的prototype中加入一个方法叫s(),那么s()中的this指的就是这个新对象。能够得到在new时候赋予该对象的属性值</p>
<p> var E = function(a) {</p>
<pre><code>this.a = a;
</code></pre><p> }</p>
<p> E.prototype.s = function () {</p>
<pre><code>return this.a;
</code></pre><p> };</p>
<p> var e = new E(“test2”);<br> console.log(e.s()); //“test2”</p>
<p> var F = function(a) {</p>
<pre><code>this.a = a;
</code></pre><p> }</p>
<p> F.prototype.s = function () {</p>
<pre><code>return this.a;
</code></pre><p> };</p>
<p> var f = F(“test2”);<br> console.log(f);//undefined</p>
</li>
<li><p>如果我们修改了函数的prototype,又会发生什么样的情况呢？ 那么就会发生类似继承的功能，其实就是js的伪类实现。</p>
<p> var E = function(a) {</p>
<pre><code>this.a = a;
</code></pre><p> }</p>
<p> E.prototype.s = function () {</p>
<pre><code>return this.a;
</code></pre><p> };</p>
<p> var F = function(b) {</p>
<pre><code>this.b = b;
</code></pre><p> }</p>
<p> F.prototype = new E(“test1”);</p>
<p> F.prototype.x = function () {</p>
<pre><code>return this.b;
</code></pre><p> };</p>
<p> var f = new F(“test2”);</p>
<p> console.log(f);     //object<br> console.log(f.s()); //test1<br> console.log(f.x()); //test2</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2016/02/03/2015-12-17-localstorage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/03/2015-12-17-localstorage/" itemprop="url">使用sessionStorage、localStorage存储数组与对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-03T14:00:16+08:00">
                2016-02-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/02/03/2015-12-17-localstorage/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/02/03/2015-12-17-localstorage/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有时候，我们需要将数据存储到sessionStorage和localStorage中，这样做的好处有：</p>
<p>1 缓存数据</p>
<p>2 减少对内存的占用</p>
<p>但是，storage只能存储字符串的数据，对于JS中常用的数组或对象却不能直接存储。</p>
<pre><code>var obj = { name:&apos;Jim&apos; };
sessionStorage.obj = obj; 
localStorage.obj = obj; 

var arr = [1,2,3]; 
sessionStorage.obj = arr; 
localStorage.obj = arr;
</code></pre><p>上面的写法都是不能成功的！但我们可以通过JSON对象提供的parse和stringify将其他数据类型转化成字符串，再存储到storage中就可以了。请看下面的代码。</p>
<pre><code>var obj = { name:&apos;Jim&apos; }; 
var str = JSON.stringify(obj); 

//存入 
sessionStorage.obj = str; 
//读取 
str = sessionStorage.obj; 
//重新转换为对象 
obj = JSON.parse(str);
</code></pre><hr>
<pre><code>Storage.prototype.setObject = function(key, value) {
    this.setItem(key, JSON.stringify(value));
}

Storage.prototype.getObject = function(key) {
    var value = this.getItem(key);
    return value &amp;&amp; JSON.parse(value);
}
</code></pre><p>localStorage也一样，只是和sessionStorage的存储时间不一样。</p>
<p>需要注意的是，JS中的数组本质上也是对象类型，所以上面的代码对数组也是适用的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/28/2015-11-28-trigger/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/28/2015-11-28-trigger/" itemprop="url">trigger的使用场景</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-28T21:24:21+08:00">
                2015-11-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/28/2015-11-28-trigger/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/28/2015-11-28-trigger/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>trigger相对于click等普通的预定义事件，主要有两点不一样。</p>
<ol>
<li><p>trigger可以接受多个参数。</p>
</li>
<li><p>trigger可以自定义事件</p>
</li>
</ol>
<p>下面是实例代码</p>
<pre><code>(function($){
  var btn = $(&quot;#btn&quot;);
  btn.bind(&apos;clicka&apos;,function(e,a,b,c){
    console.log(a,b,c)
  });
  btn.click(function(){
    btn.trigger(&apos;clicka&apos;,[&apos;hello&apos;,&apos;world&apos;,&apos;flying&apos;])  // hello world flying    
  })
  btn.trigger(&apos;clicka&apos;,[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]); // a,b,c  
})(jQuery);
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/21/2015-11-16-gvim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/21/2015-11-16-gvim/" itemprop="url">gVim的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-21T15:35:18+08:00">
                2015-11-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/21/2015-11-16-gvim/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/21/2015-11-16-gvim/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>安装好gvim后可以进行简单设计，配置文件在安装目录下_vimrc：</p>
<pre><code>set nu!            &quot;设置行号
colorscheme desert &quot;设置配色方案
syntax on          &quot;语法高亮
syntax enable
set nobackup        &quot;不生成备份文件
set showmatch       &quot;设置匹配模式
set smartindent     &quot;设置只能对齐
set ai!             &quot;设置自动缩进
set fileencodings=utf-8,gbk
set ambiwidth=double      &quot;设置中文支持
set guifont=consolas:h12  &quot;设置字体及大小
</code></pre><h1 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h1><ol>
<li><p>vi打开文件默认的命令模式。此时可以敲击命令进行编辑文件</p>
<pre><code>vim 文件名 //打开一个文件，当文件不存在时创建文件
vim +5 文件名 // 打开一个文件，光标定位到第五行。加号后面的数字为光标定位的行号。
vim +/search // 打开一个文件，搜索“search&quot;,并定位到第一次出现的行。然后敲 n 可游离到下一次出现的地方
vim 文件1 文件2  // 一次打开多个文件。 底行命令行 :n 可转到当前文件的下一个文件。相反 :N 返回到上一个文件。

dd  // 删除光标所在行
yy  // 复制光标所在行
o   // 光标所在行下行插入一行并切换到输入模式
p   // 光标所在行下行粘贴
P   // 光标所在行上行粘贴
</code></pre></li>
</ol>
<ol start="2">
<li><p>文本编辑模式。当敲击字母  a  即可进入编辑模式</p>
</li>
<li><p>底行命令行模式。在命令模式下输入 ： 时，在底下输入命令行，此时命令不会立即执行，要回车才会执行。比如<code>:wq</code>为保存文件退出。</p>
<pre><code>:w  //保存
:q  //退出
:!  //强制执行
:ls //显示所有打开的文件
:n  //下一个文件
:15 //光标定位到哪一行
:/xxx  //从光标处向下搜索xxx
:?xxx  //从光标处向上搜索xxx
</code></pre></li>
</ol>
<p>vi（vim）是上Linux非常常用的编辑器，很多Linux发行版都默认安装了vi(vim)。vi(vim)命令繁多但是如果使用灵活之后将会大大提高效率。vi是“visual interface”的缩写，vim是vi IMproved(增强版的vi)。在一般的系统管理维护中vi就够用，如果想使用代码加亮的话可以使用vim。</p>
<p>vi有3个模式：插入模式、命令模式、低行模式</p>
<pre><code>1）插入模式：在此模式下可以输入字符，按ESC将回到命令模式。
2）命令模式：可以移动光标、删除字符等。
3）低行模式：可以保存文件、退出vi、设置vi、查找等功能(低行模式也可以看作是命令模式里的)。
</code></pre><p>进入vi的命令</p>
<pre><code>vi filename :打开或新建文件，并将光标置于第一行首
vi +n filename ：打开文件，并将光标置于第n行首
vi + filename ：打开文件，并将光标置于最后一行首
vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处
vi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename
vi -o/O filename1 filename2 ... ：打开多个文件，依次进行编辑
</code></pre><p>vi 关闭文件</p>
<pre><code>:w       //保存文件
:w vpser.net //保存至vpser.net文件
:q          //退出编辑器，如果文件已修改请使用下面的命令
:q!        //退出编辑器，且不保存
:wq         //退出编辑器，且保存文件
</code></pre><p>移动光标类命令</p>
<pre><code>h ：光标左移一个字符
l ：光标右移一个字符
space：光标右移一个字符
Backspace：光标左移一个字符
k或Ctrl+p：光标上移一行
j或Ctrl+n ：光标下移一行
Enter ：光标下移一行
w或W ：光标右移一个字至字首
b或B ：光标左移一个字至字首
e或E ：光标右移一个字至字尾
) ：光标移至句尾
( ：光标移至句首
}：光标移至段落开头
{：光标移至段落结尾
nG：光标移至第n行首
n+：光标下移n行
n-：光标上移n行
n$：光标移至第n行尾
H ：光标移至屏幕顶行
M ：光标移至屏幕中间行
L ：光标移至屏幕最后行
0：（注意是数字零）光标移至当前行首
$：光标移至当前行尾
n+        //向下跳n行
n-         //向上跳n行
nG        //跳到行号为n的行
G           //跳至文件的底部
</code></pre><p>屏幕翻滚类命令</p>
<pre><code>Ctrl+u：向文件首翻半屏
Ctrl+d：向文件尾翻半屏
Ctrl+f：向文件尾翻一屏
Ctrl＋b；向文件首翻一屏
nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。
</code></pre><p>插入文本类命令</p>
<pre><code>i ：在光标前
I ：在当前行首
a：光标后
A：在当前行尾
o：在当前行之下新开一行
O：在当前行之上新开一行
r：替换当前字符
R：替换当前字符及其后的字符，直至按ESC键
s：从当前光标位置处开始，以输入的文本替代指定数目的字符
S：删除指定数目的行，并以所输入文本代替之
ncw或nCW：修改指定数目的字
nCC：修改指定数目的行
</code></pre><p>复制、粘贴</p>
<pre><code>yy    //将当前行复制到缓存区，也可以用 &quot;ayy 复制，&quot;a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。
nyy   //将当前行向下n行复制到缓冲区，也可以用 &quot;anyy 复制，&quot;a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。
yw    //复制从光标开始到词尾的字符。
nyw   //复制从光标开始的n个单词。
y^      //复制从光标到行首的内容。  
y$      //复制从光标到行尾的内容。
p        //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用&quot;ap 进行粘贴。
P        //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用&quot;aP 进行粘贴。
</code></pre><p>文本替换</p>
<pre><code>:s/old/new      //用new替换行中首次出现的old
:s/old/new/g         //用new替换行中所有的old
:n,m s/old/new/g     //用new替换从n到m行里所有的old
:%s/old/new/g      //用new替换当前文件里所有的old
</code></pre><p>简单替换表达式</p>
<pre><code>:%s/four/4/g
</code></pre><p>“%” 范围前缀表示在所有行中执行替换，最后的 “g” 标记表示替换行中的所有匹配点，如果仅仅对当前行进行操作，那么只要去掉%即可</p>
<p>如果你有一个像 “thirtyfour” 这样的单词，上面的命令会出错。这种情况下，这个单词会被替换成”thirty4″。要解决这个问题，用 “&lt;”来指定匹配单词开头：</p>
<pre><code>:%s/&lt;four/4/g
</code></pre><p>显然，这样在处理 “fourty” 的时候还是会出错。用 “&gt;” 来解决这个问题：</p>
<pre><code>:%s/&lt;four&gt;/4/g
</code></pre><p>如果你在编码，你可能只想替换注释中的 “four”，而保留代码中的。由于这很难指定，可以在替换命令中加一个 “c” 标记，这样，Vim 会在每次替换前提示你：</p>
<pre><code>:%s/&lt;four&gt;/4/gc
</code></pre><p>单词精确匹配替换</p>
<pre><code>sed -e &quot;s/\&lt;old\&gt;/new/g&quot;  file
</code></pre><p>删除命令</p>
<pre><code>ndw或ndW：删除光标处开始及其后的n-1个字
do：删至行首
d$：删至行尾
ndd：删除当前行及其后n-1行
x或X：删除一个字符，x删除光标后的，而X删除光标前的
Ctrl+u：删除输入方式下所输入的文本
x         //删除当前字符
nx         //删除从光标开始的n个字符
dd       //删除当前行
ndd     //向下删除当前行在内的n行
u        //撤销上一步操作
U       //撤销对当前行的所有操作
</code></pre><p>搜索及替换命令</p>
<pre><code>/pattern：从光标开始处向文件尾搜索pattern
?pattern：从光标开始处向文件首搜索pattern
n：在同一方向重复上一次搜索命令
N：在反方向上重复上一次搜索命令
：s/p1/p2/g：将当前行中所有p1均用p2替代
：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代
：g/p1/s//p2/g：将文件中所有p1均用p2替换
</code></pre><p>选项设置</p>
<pre><code>all：列出所有选项设置情况
term：设置终端类型
ignorance：在搜索中忽略大小写
list：显示制表位(Ctrl+I)和行尾标志（$)
number：显示行号
report：显示由面向行的命令修改过的数目
terse：显示简短的警告信息
warn：在转到别的文件时若没保存当前文件则显示NO write信息
nomagic：允许在搜索模式中，使用前面不带“/”的特殊字符
nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始
mesg：允许vi显示其他用户用write写到自己终端上的信息
</code></pre><p>最后行方式命令</p>
<pre><code>：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下
：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下
：n1,n2 d ：将n1行到n2行之间的内容删除
：w ：保存当前文件
：e filename：打开文件filename进行编辑
：x：保存当前文件并退出
：q：退出vi
：q!：不保存文件并退出vi
：!command：执行shell命令command
：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入
：r!command：将命令command的输出结果放到当前行        
</code></pre><p>寄存器操作</p>
<pre><code>“?nyy：将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字
“?nyw：将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字
“?nyl：将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字
“?p：取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字
ndd：将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-29-study-object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-29-study-object/" itemprop="url">深入学习JavaScript对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-29-study-object/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-29-study-object/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JavaScript中，除了五种原始类型（即数字，字符串，布尔值，null，undefined）之外的都是对象了，所以，不把对象学明白怎么继续往下学习呢？</p>
<p>一.概述<br>对象是一种复合值，它将很多值（原始值或其他对象）聚合在一起，可通过属性名访问这些值。而属性名可以是包含空字符串在内的任意字符串。JavaScript对象也可以称作一种数据结构，正如我们经常听说的“散列（hash）”、“散列表（hashtable）”、“字典（dictionary）”、“关联数组（associative array）”。</p>
<p>JavaScript中对象 可以分为三类：</p>
<p>①内置对象，例如数组、函数、日期等；</p>
<p>②宿主对象，即JavaScript解释器所嵌入的宿主环境（比如浏览器）定义的，例如HTMLElement等；</p>
<p>③自定义对象，即程序员用代码定义的；</p>
<p>对象的属性可以分为两类：</p>
<p>①自有属性（own property）：直接在对象中定义的属性；</p>
<p>②继承属性（inherited property）：在对象的原型对象中定义的属性（关于原型对象下面会详谈）；</p>
<p>二.对象的创建<br>既然学习对象，又怎能不懂如何创建对象呢？面试前端岗位的同学，可能都被问过这个基础问题吧：<br>创建JavaScript对象的两种方法是什么？（或者：说说创建JavaScript对象的方法？）</p>
<p>这个问题我就被问过两次。“创建对象的两种方法”这种说法网上有很多，但是据我所看书籍来说是有三种方法的！下面我们就来具体谈谈这三种方法：</p>
<p>1.对象直接量<br>对象直接量由若干名/值对组成的映射表，名/值对中间用冒号分隔，名/值对之间用逗号分隔，整个映射表用花括号括起来。属性名可以是JavaScript标识符也可以是字符串直接量，也就是说下面两种创建对象obj的写法是完全一样的：</p>
<pre><code>var obj = {x: 1, y: 2};
var obj = {&apos;x&apos;: 1, &apos;y&apos;:2};
</code></pre><p>2.通过new创建对象<br>new运算符后跟随一个函数调用，即构造函数，创建并初始化一个新对象。例如：</p>
<pre><code>var o = new Object();    //创建一个空对象，和{}一样
var a = new Array();    //创建一个空数组，和[]一样
var d = new Date();    //创建一个表示当前时间的Date对象
</code></pre><p>关于构造函数相关的内容以后再说。</p>
<p>3.Object.create()<br>ECMAScript5定义了一个名为Object.create()的方法，它创建一个新对象，其中第一个参数是这个对象的原型对象（好像还没解释原型对象…下面马上就说），第二个可选参数用以对对象的属性进行进一步的描述，第二个参数下面再说（因为这第三种方法是ECMAScript5中定义的，所以以前大家才经常说创建对象的两种方法的吧？个人觉得应该是这个原因）。这个方法使用很简单：</p>
<pre><code>var o1 = Object.create({x: 1, y: 2});    //对象o1继承了属性x和y
var o2 = Object.create(null);    //对象o2没有原型
</code></pre><p>下面三种的完全一样的：</p>
<pre><code>var obj1 = {};
var obj2 = new Object();
var obj3 = Object.create(Object.prototype);
</code></pre><p>为了解释为啥这三种方式是完全一样的，我们先来解释下JavaScript中的原型对象（哎，让客官久等了！），记得一位大神说过：</p>
<p>Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。</p>
<p>面向对象的编程语言JavaScript，没有类！！！那么，它是怎么实现继承的呢？没错，就是通过原型对象。基本上每一个JavaScript对象（null除外）都和另一个对象相关联，“另一个”对象就是所谓的原型对象（原型对象也可以简称为原型，并没有想象的那么复杂，它也只是一个对象而已）。每一个对象都从原型对象继承属性，并且一个对象的prototype属性的值（这个属性在对象创建时默认自动生成，并不需要显示的自定义）就是这个对象的原型对象，即obj.prototype就是对象obj的原型对象。</p>
<p>原型对象先说到这，回到上面的问题，有了对原型对象的认识，下面就是不需要过多解释的JavaScript语言规定了：</p>
<p>①所有通过对象直接量创建的对象的原型对象就是Object.prototype对象；</p>
<p>②通过关键字new和构造函数创建的对象的原型对象就是构造函数prototype属性的值，所以通过构造函数Object创建的对象的原型就是Object.prototype了；</p>
<p>现在也补充了第三种创建对象的方法Object.create()第一个参数的含义。</p>
<p>三.属性的查询和设置<br>学会了如何创建对象还不够啊，因为对象只有拥有一些属性才能真正起到作用滴！那么，就继续往下学习对象的属性吧！</p>
<p>可以通过点（.）或方括号（[]）运算符来获取和设置属性的值。对于点（.）来说，右侧必须是一个以属性名命名的标识符（注意：JavaScript语言的标识符有自己的合法规则，并不同于带引号的字符串）；对于方括号（[]）来说，方括号内必须是一个字符串表达式（字符串变量当然也可以喽，其他可以转换成字符串的值比如数字什么的也是都可以滴），这个字符串就是属性的名字。正如下面例子：</p>
<pre><code>var obj = {x: 1, y: 2};
obj.x = 5;
obj[&apos;y&apos;] = 6
</code></pre><p>概述中说过， JavaScript对象具有”自有属性“，也有“继承属性”。当查询对象obj的属性x时，首先会查找对象obj自有属性中是否有x，如果没有，就会查找对象obj的原型对象obj.prototype是否有属性x，如果没有，就会进而查找对象obj.prototype的原型对象obj.prototype.prototype是否有属性x，就这样直到找到x或者查找到的原型对象是undefined的对象为止。可以看到，一个对象上面继承了很多原型对象，这些原型对象就构成了一个”链“，这也就是我们平时所说的“原型链”，这种继承也就是JavaScript中“原型式继承”（prototypal inheritance）。</p>
<p>对象o查询某一属性时正如上面所说会沿着原型链一步步查找，但是其设置某一属性的值时，只会修改自有属性（如果对象没有这个属性，那就会添加这个属性并赋值），并不会修改原型链上其他对象的属性。</p>
<p>四.存取器属性getter和setter<br>上面我们所说的都是很普通的对象属性，这种属性称做“数据属性”（data property），数据属性只有一个简单的值。然而在ECMAScript 5中，属性值可以用一个或两个方法替代，这两个方法就是getter和setter，有getter和setter定义的属性称做“存取器属性”（accessor property）。</p>
<p>当程序查询存取器属性的值时，JavaScript调用getter方法（无参数）。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript调用setter方法，将赋值表达式右侧的值当做参数传入setter。如果属性同时具有getter和setter方法，那么它就是一个读/写属性；如果它只有getter方法，那么它就是一个只读属性，给只读属性赋值不会报错，但是并不能成功；如果它只有setter方法，那么它是一个只写属性，读取只写属性总是返回undefined。看个实际的例子：</p>
<pre><code>var p = {
x: 1.0,
y: 2.0,
get r(){ return Math.sqrt(this.x*this.x + this.y*this.y); };
set r(newvalue){
    var oldvalue = Math.sqrt(this.x*this.x + this.y*this.y);
    var ratio = newvalue/oldvalue;
    this.x *= ratio;
    this.y *= ratio;
},
    get theta(){ return Math.atan2(this.y, this.x); },
 print: function(){ console.log(&apos;x:&apos;+this.x+&apos;, y:&apos;+this.y); }
};
</code></pre><p>正如例子所写，存取器属性定义一个或两个和属性同名的函数，这个函数定义并没有使用function关键字，而是使用get和set，也没有使用冒号将属性名和函数体分隔开。对比一下，下面的print属性是一个函数方法。注意：这里的getter和setter里this关键字的用法，JavaScript把这些函数当做对象的方法来调用，也就是说，在函数体内的this指向这个对象。下面看下实例运行结果：</p>
<p>正如控制台的输出，r、theta同x，y一样只是一个值属性，print是一个方法属性。</p>
<p>ECMAScript 5增加的这种存取器，虽然比普通属性更为复杂了，但是也使得操作对象属性键值对更加严谨了。</p>
<p>五.删除属性<br>  程序猿撸码一般都是实现增、删、改、查功能，前面已经说了增、改、查，下面就说说删除吧！<br>delete运算符可以删除对象的属性，它的操作数应该是一个属性访问表达式。但是，delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性：</p>
<pre><code>var a = {p:{x:1}};
var b = a.p;
delete a.p;
</code></pre><p>执行这段代码后b.x的值依然是1，由于已删除属性的引用依然存在，所以有时这种不严谨的代码会造成内存泄露，所以在销毁对象的时候，要遍历属性中的属性，依次删除。</p>
<p>delete表达式返回true的情况：</p>
<p>①删除成功或没有任何副作用（比如删除不存在的属性）时；</p>
<p>②如果delete后不是一个属性访问表达式；</p>
<pre><code>var obj = {x: 1,get r(){return 5;},set r(newvalue){this.x = newvalue;}};
delete obj.x;    //删除对象obj的属性x，返回true
delete obj.x;    //删除不存在的属性，返回true
delete obj.r;    //删除对象obj的属性r，返回true
delete obj.toString;    //没有任何副作用（toString是继承来的，并不能删除），返回true
delete 1;    //数字1不是属性访问表达式，返回true
</code></pre><p>delete表达式返回false的情况：</p>
<p>①删除可配置性（可配置性是属性的一种特性，下面会谈到）为false的属性时；</p>
<pre><code>delete Object.prototype;    //返回false，prototype属性是不可配置的
//通过var声明的变量或function声明的函数是全局对象的不可配置属性
var x = 1;
delete this.x;    //返回false
function f() {}
delete this.f;    //返回false
</code></pre><p>六.属性的特性<br>上面已经说到了属性的可配置性特性，因为下面要说的检测属性和枚举属性还要用到属性的特性这些概念，所以现在就先具体说说属性的特性吧！</p>
<p>除了包含名字和值之外，属性还包含一些标识它们可写、可枚举、可配置的三种特性。在ECMAScript 3中无法设置这些特性，所有通过ECMAScript 3的程序创建的属性都是可写的、可枚举的和可配置的，且无法对这些特性做修改。ECMAScript 5中提供了查询和设置这些属性特性的API。这些API对于库的开发者非常有用，因为：</p>
<p>①可以通过这些API给原型对象添加方法，并将它们设置成不可枚举的，这让它们更像内置方法;</p>
<p>②可以通过这些API给对象定义不能修改或删除的属性，借此“锁定”这个对象；</p>
<p>在这里我们将存取器属性的getter和setter方法看成是属性的特性。按照这个逻辑，我们也可以把属性的值同样看做属性的特性。因此，可以认为属性包含一个名字和4个特性。数据属性的4个特性分别是它的值（value）、可写性（writable）、可枚举性（enumerable）和可配置性（configurable）。存取器属性不具有值特性和可写性它们的可写性是由setter方法是否存在与否决定的。因此存取器属性的4个特性是读取（get）、写入（set）、可枚举性和可配置性。</p>
<p>为了实现属性特性的查询和设置操作，ECMAScript 5中定义了一个名为“属性描述符”（property descriptor）的对象，这个对象代表那4个特性。描述符对象的属性和它们所描述的属性特性是同名的。因此，数据属性的描述符对象的属性有value、writable、enumerable和configurable。存取器属性的描述符对象则用get属性和set属性代替value和writable。其中writable、enumerable和configurable都是布尔值，当然，get属性和set属性是函数值。通过调用Object.getOwnPropertyDescriptor()可以获得某个对象特定属性的属性描述符：</p>
<p>从函数名字就可以看出，Object.getOwnPropertyDescriptor()只能得到自有属性的描述符，对于继承属性和不存在的属性它都返回undefined。要想获得继承属性的特性，需要遍历原型链（不会遍历原型链？不要急，下面会说到的）。</p>
<p>要想设置属性的特性，或者想让新建属性具有某种特性，则需要调用Object.definePeoperty()，传入需要修改的对象、要创建或修改的属性的名称以及属性描述符对象：</p>
<p>可以看到：</p>
<p>① 传入Object.defineProperty()的属性描述符对象不必包含所有4个特性；</p>
<p>② 可写性控制着对属性值的修改；</p>
<p>③ 可枚举性控制着属性是否可枚举（枚举属性，下面会说的）；</p>
<p>④ 可配置性控制着对其他特性（包括前面说过的属性是否可以删除）的修改；</p>
<p>如果要同时修改或创建多个属性，则需要使用Object.defineProperties()。第一个参数是要修改的对象，第二个参数是一个映射表，它包含要新建或修改的属性的名称，以及它们的属性描述符，例如：</p>
<pre><code>var p = Object.defineProperties({},{
    x: {value: 1, writable: true, enumerable: true, configurable: true},
    y: {value: 2, writable: true, enumerable: true, configurable: true},
    r: {get: function(){return 88;}, set: function(newvalue){this.x =newvalue;},enumerable: true, configurable: true},
    greet: {value: function(){console.log(&apos;hello,world&apos;);}, writable: true, enumerable: true, configurable: true}
});
</code></pre><p>相信你也已经从实例中看出：Object.defineProperty()和Object.defineProperties()都返回修改后的对象。<br>前面我们说getter和setter存取器属性时使用对象直接量语法给新对象定义存取器属性，但并不能查询属性的getter和setter方法或给已有的对象添加新的存取器属性。在ECMAScript 5中，就可以通过Object.getOwnPropertyDescriptor()和Object.defineProperty()来完成这些工作啦！但在ECMAScript 5之前，大多数浏览器（IE除外啦）已经支持对象直接量语法中的get和set写法了。所以这些浏览器还提供了非标准的老式API用来查询和设置getter和setter。这些API有4个方法组成，所有对象都拥有这些方法。<strong>lookupGetter</strong>()和<strong>lookupSetter</strong>()用以返回一个命名属性的getter和setter方法。<strong>defineGetter</strong>()和<strong>defineSetter</strong>()用以定义getter和setter。这四个方法都是以两条下划线做前缀，两条下划线做后缀，以表明它们是非标准方法。下面是它们用法：</p>
<p>七.检测属性<br>JavaScript对象可以看做属性的集合，那么我们有时就需要判断某个属性是否存在于某个对象中，这就是接下来要说的检测属性。</p>
<p>检测一个对象的属性也有三种方法，下面就来详细说说它们的作用及区别！<br>1.in运算符<br>in运算符左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回true，否则返回false。<br>为了试验，我们先给对象Object.prototype添加一个可枚举属性m，一个不可枚举属性n；然后，给对象obj定义两个可枚举属性x,一个不可枚举属性y，并且对象obj是通过对象直接量形式创建的，继承了Object.prototype。下面看实例：</p>
<p>从运行结果可以看出：in运算符左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性（不论这些属性是否可枚举）中包含这个属性则返回true，否则返回false。</p>
<p>2.hasOwnProperty()<br>对象的hasOwnProperty()方法用来检测给定的名字是否是对象的自有属性（不论这些属性是否可枚举），对于继承属性它将返回false。下面看实例： </p>
<p>3.propertyIsEnumerable()<br>propertyIsEnumerable()是hasOwnProperty()的增强版，只有检测到是自有属性且这个属性可枚举性为true时它才返回true。还是实例：</p>
<p>八.枚举属性<br>相对于检测属性，我们更常用的是枚举属性。枚举属性我们通常使用for/in循环，它可以在循环体中遍历对象中所有可枚举的自有属性和继承属性，把属性名称赋值给循环变量。继续上实例：</p>
<p>我原来认为for/in循环跟in运算符有莫大关系的，现在看来它们的规则并不相同啊！当然，如果这里不想遍历出继承的属性，那就在for/in循环中加一层hasOwnProperty()判断：</p>
<pre><code>for(prop in obj){
    if(obj.hasOwnProperty(prop)){
        console.log(prop);
    }
}
</code></pre><p>除了for/in循环之外，ECMAScript 5还定义了两个可以枚举属性名称的函数：</p>
<p>①Object.getOwnpropertyNames()，它返回对象的所有自有属性的名称，不论是否可枚举；</p>
<p>②Object.keys()，它返回对象对象中可枚举的自有属性的名称；</p>
<p>还是实例：</p>
<p>九.对象的三个特殊属性<br>每个对象都有与之相关的原型（prototype）、类（class）和可扩展性（extensible attribute）。这三个就是对象的特殊属性（它们也只是对象的属性而已，并没有想象的复杂哦）。</p>
<p>1.原型属性<br>正如前面所说，对象的原型属性是用来继承属性的（有点绕…），这个属性如此重要，以至于我们经常把“o的原型属性”直接叫做“o的原型”。 原型属性是在实例创建之初就设置好的（也就是说，这个属性的值是JavaScript默认自动设置的，后面我们会说如何自己手动设置），前面也提到：</p>
<p>①通过对象直接量创建的对象使用Object.prototype作为它们的原型；</p>
<p>②通过new+构造函数创建的对象使用构造函数的prototype属性作为它们的原型；</p>
<p>③通过Object.create()创建的对象使用第一个参数（如果这个参数为null，则对象原型属性值为undefined；如果这个参数为undefined，则会报                    错：Uncaught TypeError: Object prototype may only be an Object or null: undefined）作为它们的原型；</p>
<p>那么，如何查询一个对象的原型属性呢？在ECMAScript 5中，将对象作为参数传入Object.getPrototypeOf()可以查询它的原型，例如：</p>
<p>但是在ECMAScript 3中，没有Object.getPrototypeOf()函数，但经常使用表达式obj.constructor.prototype来检测一个对象的原型，因为每个对象都有一个constructor属性表示这个对象的构造函数：</p>
<p>①通过对象直接量创建的对象的constructor属性指向构造函数Object()；</p>
<p>②通过new+构造函数创建的对象的constructor属性指向构造函数；</p>
<p>③通过Object.create()创建的对象的constructor属性指向与其原型对象的constructor属性指向相同；</p>
<p>要检测一个对象是否是另一个对象的原型（或处于原型链中），可以使用isPrototypeOf()方法。例如：</p>
<p>还有一个非标准但众多浏览器都已实现的对象的属性<strong>proto</strong>(同样是两个下划线开始和结束，以表明其为非标准），用以直接查询/设置对象的原型。</p>
<p>2.类属性<br>对象的类属性（class attribute）是一个字符串，用以表示对象的类型信息。ECMAScript 3 和ECMAScript 5 都未提供设置这个属性的方法，并只有一种间接的方法可以查询它。默认的toString()方法（继承自Object.prototype）返回了这种格式的字符串：[object class] 。因此，要想获得对象的类，可以调用对象的toString()方法，然后提取已返回字符串的第8到倒数第二个位置之间的字符。不过，很多对象继承的toString()方法重写了（比如：Array、Date等），为了能调用正确的toString()版本，必须间接地调用Function.call()方法。下面代码可以返回传递给它的任意对象的类：</p>
<pre><code>function classof(obj){
    if(o === null){
        return &apos;Null&apos;;
    }
    if(o === undefined){
        return &apos;Undefined&apos;;
    }
    return Object.prototype.toString.call(o).slice(8, -1);
}
</code></pre><p>classof()函数可以传入任何类型的参数。下面是使用实例：</p>
<p>总结：从运行结果可以看出通过三种方式创建的对象的类属性都是’Object’。</p>
<p>3.可扩展性<br>对象的可扩展性用以表示是否可以给对象添加新属性。所有内置对象和自定义对象都是显示可扩展的（除非将它们转换为不可扩展），宿主对象的可扩展性是由JavaScript引擎定义的。ECMAScript 5中定义了用来查询和设置对象可扩展性的函数：</p>
<p>①（查询）通过将对象传入Object.isExtensible()，来判断该对象是否是可扩展的。<br>②（设置）如果想将对象转换为不可扩展，需要调用Object.preventExtensions()，将待转换的对象作为参数传进去。注意：</p>
<p>a.一旦将对象转换为不可扩展的，就无法再将其转换回可扩展的了；</p>
<p>b.preventExtensions()只影响到对象本身的可扩展性，如果给一个不可扩展的对象的原型添加属性，这个不可扩展的对象同样会继承这些新属                          性；</p>
<p>进一步，Object.seal()和Object.preventExtensions()类似，除了能将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的。对于那些已经封闭（sealed）起来的对象是不能解封的。可以使用Object.isSealed()来检测对象是否封闭。</p>
<p>更进一步，Object.freeze()将更严格地锁定对象——“冻结”（frozen）。除了将对象设置为不可扩展和将其属性设置为不可配置之外，还可以将它自有的所有数据属性设置为只读（若对象的存取器属性有setter方法，存取器属性将不受影响，仍可通过给属性赋值调用它们）。使用Object.isFrozen()来检测对象是否总结。</p>
<p>总结：Object.preventExtensions()、Object.seal()和Object.freeze()都返回传入的对象，也就是说，可以通过嵌套的方式调用它们：</p>
<p>1 var obj = Object.seal(Object.create(Object.freeze({x:1}),{y:{value: 2, writable: true}));<br>这条语句中使用Object.create()函数传入了两个参数，即第一个参数是创建出的对象的原型对象，第二个参数是在创建对象是直接给其定义的属性，并且附带定义了属性的特性。<br>十.对象的序列化<br>前面说完了对象的属性以及对象属性的特性，东西还是蛮多的，不知道你是否已看晕。不过，下面就是比较轻松的话题了！</p>
<p>对象序列化（serialization）是指将对象的状态转换为字符串，也可以将字符串还原为对象。ECMAScript 5提供了内置函数JSON.stringify()和JSON.parse()用来序列化和还原对象。这些方法都使用JSON作为数据交换格式，JSON的全称是“JavaScript Object Notation”——JavaScript对象表示法，它的语法和JavaScript对象与数组直接量的语法非常相近：</p>
<p>其中，最后的jsonObj是obj的深拷贝（关于什么是深拷贝，什么是浅拷贝，可以参考：<a href="http://www.zhihu.com/question/23031215，第二个答案）。" target="_blank" rel="external">http://www.zhihu.com/question/23031215，第二个答案）。</a></p>
<p>JSON的语法是JavaScript的子集，它并不能表示JavaScript里的所有值。支持对象、数组、字符串、无穷大数字、true、false和null，并且它们可以序列化和还原。注意：</p>
<p>①NaN、Infinity和-Infinity序列化的结果是null；</p>
<p>②JSON.stringify()只能序列化对象可枚举的自有属性；</p>
<p>③日期对象序列化的结果是ISO格式的日期字符串（参照Date.toJSON()函数），但JSON.parse()依然保留它们的字符串形态，而不能将它们还原为                    原始日期对象；</p>
<p>④函数、RegExp、Error对象和undefined值不能序列化和还原；</p>
<p>当然，JSON.stringify()和JSON.parse()都可以接受第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作，这个我们以后再详谈。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-10-19-fis3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-10-19-fis3/" itemprop="url">fis3的一些配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-10-19-fis3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-10-19-fis3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>百度fis对于前端的一些自动化操作确实是强大的。以前一直用harpjs来做静态服务器，对于sass、jade等优化也是做的挺好，但是就是配置少了些。</p>
<p>fis3的一些常用配置备份下，尽可能的模拟出harpjs运行环境.</p>
<p>最常用的命令行：</p>
<pre><code>fis3 server start  //启动一个服务
fis3 release -wL   //发布网站，-wL参数为实时自动刷新
</code></pre><p>最常用的配置：</p>
<p><code>fis.media()</code>接口提供多种状态功能，比如有些属性配置是开发阶段的，有些是上线时需要起作用的。</p>
<pre><code>fis.media(&apos;prod&apos;).match(&apos;*.js&apos;, {
  optimizer: fis.plugin(&apos;uglify-js&apos;)
});
</code></pre><p>运行sass,jade等。</p>
<pre><code>//npm install -g fis-parser-sass
fis.match(&apos;*.scss&apos;, {
  rExt: &apos;.css&apos;, // from .scss to .css
  parser: fis.plugin(&apos;sass&apos;, {
    //fis-parser-sass option,expanded：没有缩进的、扩展的css代码。nested：嵌套缩进的css代码。compact：简洁格式的css代码。compressed：压缩后的css代码
    expanded : true
  })
});

//npm install -g fis-parser-jade
fis.match(&apos;*.jade&apos;, {
  rExt: &apos;.html&apos;,
  loaderLang: &apos;html&apos;,
  parser: fis.plugin(&apos;jade&apos;, {
    pretty  : true
  })
});
</code></pre><p>js模块化，以mod.js为例子</p>
<pre><code>// npm install [-g] fis3-hook-module
fis.hook(&apos;module&apos;, {
    mode: &apos;commonJs&apos;  // requirejs加载器设置值为 &apos;amd&apos;
});
fis.match(&apos;/mod/*.js&apos;, {
    isMod: true, // 指明模块文件，组件建议都是匿名方式 define
    release: &apos;/static/$0&apos;
});
fis.match(&apos;::package&apos;, {
    // npm install [-g] fis3-postpackager-loader
    // 分析 __RESOURCE_MAP__ 结构，来解决资源加载问题
    postpackager: fis.plugin(&apos;loader&apos;, {
        resourceType: &apos;commonJs&apos;,
        useInlineMap: true // 资源映射表内嵌
    })
})
</code></pre><p>文件压缩与合并</p>
<pre><code>fis.match(&apos;::packager&apos;, {
  postpackager: fis.plugin(&apos;loader&apos;, {
    allInOne: true
  })
});

fis.match(&apos;*.{css,scss}&apos;, {
  optimizer: fis.plugin(&apos;clean-css&apos;)
});


fis.match(&apos;*.js&apos;, {
  optimizer: fis.plugin(&apos;uglify-js&apos;)
});
</code></pre><p>关于jade编译出来后无法正常解析js模块，和文件正常合并等问题</p>
<p>我用jade编译出来的文件同原生html文件还是有差距的。</p>
<p>无法用上面方法合并压缩文件</p>
<p>js模块不能正确打包，模块化js文件没有正常加载依赖的js文件。</p>
<p>上面的问题折腾了我很久，下载了若干插件还是不行。后来找到了一个解决办法。</p>
<p>fis大牛给出帮助信息了，就是关于 fis3-postpackager-loader 插件<br>静态资源前端加载器，用来分析页面中使用的和依赖的资源（js或css）, 并将这些资源做一定的优化后插入页面中。如把零散的文件合并。</p>
<p>注意:此插件做前端硬加载，适用于纯前端项目，不适用有后端 loader 的项目。因为不识别模板语言，对于资源的分析和收集，比较的粗暴！！！</p>
<p>默认 loader 只会以 html 的方式处理后缀为 .html 的文件，如果希望其他后缀也以 html 的方式去处理，请设置 loaderLang 属性。</p>
<pre><code>fis.match(&apos;*.md&apos;, {
  loaderLang: &apos;html&apos;
});
</code></pre><p><a href="https://github.com/fex-team/fis3-postpackager-loader" target="_blank" rel="external">fis3-postpackager-loader 参考文档</a></p>
<p>Fis中嵌入资源</p>
<p>嵌入资源能解决上面jade的问题。可以在html文件中切入一个jade文件。</p>
<pre><code>&lt;link rel=&quot;import&quot; href=&quot;a.jade?__inline&quot;&gt;
</code></pre><p>依照这个原理，其实模块化很容易实现。如上a.jade中可以引入相关的css,js文件。当然在css中也可引入css文件。</p>
<pre><code>@import url(&apos;demo.css?__inline&apos;);
</code></pre><p>这个会和sass文件中引入scss文件一样。在html这css中文件后缀加上?__inline会将图片文件转化为base64字符串。</p>
<p>Tips</p>
<p>最近es6好像开始火起来了。在fis上试着装了一个es6转es5插件。</p>
<pre><code>//npm install -g fis-parser-es6-babel
fis.set(&apos;project.fileType.text&apos;, &apos;es6&apos;);
fis.match(&apos;*.es6&apos;, {
    rExt: &apos;.js&apos;,
    parser: fis.plugin(&apos;es6-babel&apos;, {})
});
</code></pre><p>一个小问题就是Sublime3无法为.es6的文件语法高亮，其实很简单：</p>
<p>打开文件后点击右下角的Plain Text，在出现的文件格式中选择open all with current extension as… -&gt;”需要显示的语法类型”。这样以后打开这个类型的文件就会自动进行语法高亮了。</p>
<p>全局或本地安装插件 </p>
<pre><code>npm install [-g] fis3-hook-relative 
</code></pre><p>fis-conf.js 启用插件 </p>
<pre><code>fis.hook(&apos;relative&apos;); 
</code></pre><p>让所有文件，都使用相对路径。</p>
<pre><code>fis.match(&apos;**&apos;, { relative: true })
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-10-19-touch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-10-19-touch/" itemprop="url">微信等移动端浏览器禁止页面上下拉动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-10-19-touch/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-10-19-touch/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>微信等内置浏览器在页面上下拉动时有默认事件，下面代码可以禁止。</p>
<pre><code>handler = function (e) {
  e.preventDefault();
};
document.addEventListener(&quot;touchmove&quot;, handler, false);
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-10-19-settimeout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-10-19-settimeout/" itemprop="url">从setTimeout说事件循环模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-10-19-settimeout/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-10-19-settimeout/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.从setTimeout说起</p>
<p>setTimeout()方法不是ecmascript规范定义的内容，而是属于BOM提供的功能。查看w3school对setTimeout()方法的定义，setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。</p>
<p>语法setTimeout(fn,millisec)，其中fn表示要执行的代码，可以是一个包含javascript代码的字符串，也可以是一个函数。第二个参数millisec是以毫秒表示的时间，表示fn需推迟多长时间执行。</p>
<p>调用setTimeout()方法之后，该方法返回一个数字，这个数字是计划执行代码的唯一标识符，可以通过它来取消超时调用。</p>
<p>起初我对 setTimeout()的使用比较简单，对其运行机理也没有深入的理解，直到看到下面代码</p>
<pre><code>var start = new Date;
setTimeout(function(){
var end = new Date;
console.log(&apos;Time elapsed:&apos;, end - start, &apos;ms&apos;);
}, 500);
while (new Date - start &lt; 1000) {};
</code></pre><p>在我最初对setTimeout()的认识中，延时设置为500ms，所以输出应该为Time elapsed: 500 ms。因为在直观的理解中，Javascript执行引擎，在执行上述代码过程中，应当是一个由上往下的顺序执行过程，setTimeout函数是先于while语句执行的。可是实际上，上述代码运行多次后，输出至少是延迟了1000ms。</p>
<p>2.根据结果找原因</p>
<p>看过了Java.util.Timer对类似setTimeout()的实现方案，继续回到前文Javascript的setTimeout()方法中，再来看看之前的输出为什么与预期不符。</p>
<pre><code>var start = new Date;
setTimeout(function(){
var end = new Date;
console.log(&apos;Time elapsed:&apos;, end - start, &apos;ms&apos;);
}, 500);
while (new Date - start &lt; 1000) {};
</code></pre><p>通过阅读代码不难看出，setTimeout()方法执行在while()循环之前，它声明了“希望”在500ms之后执行一次匿名函数，这一声明，也即对匿名函数的注册，在setTimeout()方法执行后立即生效。 代码最后一行的while循环会持续运行1000ms， 通过setTimeout()方法注册的匿名函数输出的延迟时间总是大于1000ms， 说明对这一匿名函数的实际调用 被while()循环阻塞了，实际的调用 在while()循环阻塞结束后才真正执行。</p>
<p>而在Java.util.Timer中，对于定时任务的解决方案是通过多线程手段实现的，任务对象存储在任务队列，由专门的调度线程，在新的子线程中完成任务的执行。通过schedule()方法注册一个异步任务时，调度线程在子线程立即开始工作，主线程不会阻塞任务的运行。</p>
<p>这就是Javascript与Java/C#之类语言的一大差异，<strong>即Javascript的单线程机制</strong>。在现有浏览器环境中，Javascript执行引擎是单线程的，主线程的语句和方法，会阻塞定时任务的运行，执行引擎只有在执行完主线程的语句后，定时任务才会实际执行，这期间的时间，可能大于注册任务时设置的延时时间。在这一点上，Javascript与Java/C#的机制很不同。</p>
<p>3.事件循环模型</p>
<p>在单线程的Javascript引擎中，setTimeout()是如何运行的呢，这里就要提到浏览器内核中的事件循环模型了。简单的讲，在Javascript执行引擎之外，有一个任务队列，当在代码中调用setTimeout()方法时，注册的延时方法会交由浏览器内核其他模块（以webkit为例，是webcore模块）处理，当延时方法到达触发条件，即到达设置的延时时间时，这一延时方法被添加至任务队列里。这一过程由浏览器内核其他模块处理，与执行引擎主线程独立，执行引擎在主线程方法执行完毕，到达空闲状态时，会从任务队列中顺序获取任务来执行，这一过程是一个不断循环的过程，称为事件循环模型。</p>
<p>4.webkit中timer的实现</p>
<p>到这里已经可以彻底理解下面代码的执行流程，执行引擎先将setTimeout()方法入栈被执行，执行时将延时方法交给内核相应模块处理。引擎继续处理后面代码，while语句将引擎阻塞了1秒，而在这过程中，内核timer模块在0.5秒时已将延时方法添加到任务队列，在引擎执行栈清空后，引擎将延时方法入栈并处理，最终输出的时间超过预期设置的时间。</p>
<pre><code>var start = new Date;
setTimeout(function(){
var end = new Date;
console.log(&apos;Time elapsed:&apos;, end - start, &apos;ms&apos;);
}, 500);
while (new Date - start &lt; 1000) {};
</code></pre><p>前面事件循环模型图中提到的WebAPIs部分，提到了DOM事件，AJAX调用和setTimeout方法，图中简单的把它们总结为WebAPIs，而且他们同样都把回调函数添加到任务队列等待引擎执行。这是一个简化的描述，实际上浏览器内核对DOM事件、AJAX调用和setTimeout方法都有相应的模块来处理，webkit内核在Javasctipt执行引擎之外，有一个重要的模块是webcore模块，html的解析，css样式的计算等都由webcore实现。对于图中WebAPIs提到的三种API，webcore分别提供了DOM Binding、network、timer模块来处理底层实现，这里还是继续以setTimeout为例，看下timer模块的实现。</p>
<p>Timer类是webkit 内核的一个必需的基础组件，通过阅读源码可以全面理解其原理，本文对其简化，分析其执行流程。</p>
<p>通过setTimeout()方法注册的延时方法，被传递给webcore组件timer模块处理。timer中关键类为TheadTimers类，其包含两个重要成员，TimerHeap任务队列和SharedTimer方法调度类。延时方法被封装为timer对象，存储在TimerHeap中。和Java.util.Timer任务队列一样，TimerHeap同样采用最小堆的数据结构，以nextFireTime作为关键字排序。SharedTimer作为TimerHeap调度类，在timer对象到达触发条件时，通过浏览器平台相关的接口，将延时方法添加到事件循环模型中提到的任务队列中。</p>
<p><strong>TimerHeap采用最小堆的数据结构，预期延时时间最小的任务最先被执行，同时，预期延时时间相同的两个任务，其执行顺序是按照注册的先后顺序执行 。</strong></p>
<pre><code>var start = new Date;
setTimeout(function(){
console.log(&apos;fn1&apos;);
}, 20);
setTimeout(function(){
console.log(&apos;fn2&apos;);
}, 30);
setTimeout(function(){
console.log(&apos;another fn2&apos;);
}, 30);
setTimeout(function(){
console.log(&apos;fn3&apos;);
}, 10);
console.log(&apos;start while&apos;);
while (new Date - start &lt; 1000) {};
console.log(&apos;end while&apos;);
</code></pre><p>上述代码输出依次为</p>
<pre><code>start while

end while

fn3

fn1

fn2

another fn2
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-11-event/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-11-event/" itemprop="url">前端进阶之路：点击事件绑定</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-11-event/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-11-event/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>引言</p>
<p>前端之所以被称为前端，是因为它是整个 Web 技术栈中距离用户最近、直接与用户进行交互的一环。而网页界面与用户的交互通常是通过各种事件来达成的；在各种事件之中，点击事件 往往又是最常见、最通用的一种界面事件。</p>
<p>本文将介绍我在 “点击事件绑定” 这一场景下的进阶之路。</p>
<p>背景</p>
<p>我是一个前端小兵，我在一家互联网公司做做一些简单的业务开发。</p>
<p>某一天，我接到了一个需求，做一个抽奖功能。公司里的前辈们已经完成了业务逻辑，而且已经提供了业务功能的接口，只需要我制作页面并完成事件绑定即可。</p>
<p>开动</p>
<p>我写好了页面，页面中有一个 ID 为 lucky-draw 的按钮元素。接下来，我需要为它绑定点击事件。我是这样写的：</p>
<pre><code>var btn = document.getElementById(&apos;lucky-draw&apos;)
btn.onclick = function () {
    BX.luckyDraw()
}
</code></pre><p>这其中 BX.luckyDraw() 就是前辈们提供的业务接口，执行它就可以运行后续的抽奖功能。</p>
<p>我测试了一下，代码工作正常，于是很开心地准备上线。</p>
<p>第一关</p>
<p>然而前辈们告诉我，这些重要功能的按钮是需要加统计的。这也难不倒我，因为我很熟悉统计系统的 API。于是我修改了一下事件绑定的代码：</p>
<pre><code>btn.onclick = function () {
    BX.luckyDraw()
    BX.track(&apos;lucky-draw&apos;)
}
</code></pre><p>这样做是有效的，但前辈们又告诉我，因为某些原因，统计代码和业务代码是分布在不同位置的，以上代码需要拆开。于是我尝试这样修改：</p>
<pre><code>btn.onclick = function () {
    BX.luckyDraw()
}

// other codes...

btn.onclick = function () {
    BX.track(&apos;lucky-draw&apos;)
}
</code></pre><p>结果发现点击按钮时的抽奖功能失效了。原来，使用 .onclick 这样的事件属性来绑定事件有一个非常大的缺点，重复赋值会覆盖旧值。也就是说，这种方式只能绑定最后一次赋值的事件处理函数。</p>
<p>我硬着头皮去请教前辈，才知道原来这种方式早已经不推荐使用了，应该使用 DOM 标准的事件绑定 API 来处理（在旧版 IE 下有一些兼容性问题，这里不展开）。因此我的代码改成了这样：</p>
<pre><code>btn.addEventListener(&apos;click&apos;, function () {
    BX.luckyDraw()
}, false)

// other codes...

btn.addEventListener(&apos;click&apos;, function () {
    BX.track(&apos;lucky-draw&apos;)
}, false)
</code></pre><p>所有功能终于又正常了，我很开心地准备上线。</p>
<p>第二关</p>
<p>事实证明我还是太天真了，PM 是不会一次性把所有需求都告诉你的。原来，这个抽奖功能还需要做 A/B 测试，也就是说，只有一半的用户会看到这个抽奖功能。</p>
<p>这意味着用户的页面上可能根本没有 btn 这个元素，那么 btn.addEventListener(…) 这一句直接就抛错了。因此，在为按钮绑定事件处理函数之前，我不得不先判断一下：</p>
<pre><code>if (btn) {
    btn.addEventListener(&apos;click&apos;, function () {
        BX.luckyDraw()
    }, false)
}

// other codes...

if (btn) {
    btn.addEventListener(&apos;click&apos;, function () {
        BX.track(&apos;lucky-draw&apos;)
    }, false)
}
</code></pre><p>虽然这样的代码在所有用户的页面上都可以正常工作，但这些预先判断看起来很蛋疼啊。我再次带着疑惑向前辈请教。前辈慈祥地看着我，说出了一句经典名言：</p>
<p>傻瓜，为什么不用万能的 jQuery 呢？</p>
<p>原来，神奇的 jQuery 允许我们忽略很多细节，比如这种没有取到元素的情况会被它默默地消化掉。而且 jQuery 的事件绑定方法也不存在兼容性问题，API 也比较好看。不错不错，不管网上的大神们怎么喷 jQuery，但它简直是我的救星啊！</p>
<p>于是，我的代码变成了以下这样：</p>
<pre><code>var $btn = $(&apos;#lucky-draw&apos;)
$btn.on(&apos;click&apos;, function () {
    BX.luckyDraw()
})

// other codes...

$btn.on(&apos;click&apos;, function () {
    BX.track(&apos;lucky-draw&apos;)
})
</code></pre><p>我的代码看起来像那么回事了，我很开心地准备上线。</p>
<p>第三关</p>
<p>当然，我的故事不会这么快结束。要知道，对一个有追求的前端团队来说，不断提升用户体验是永恒的目标。比如，我们网站使用了一些方法来提升页面加载性能，部分页面内容并不是原本存在于页面中的，而是在用户需要时，由 JavaScript 动态生成的。</p>
<p>拿这个抽奖功能来说，抽奖按钮存在于一个名为 “惊喜” 的 tab 中，而这个 tab 在初始状态下是没有内容的，只有当用户切换到这个 tab 时，才会由 JS 填充其内容。示意代码是这样的：</p>
<pre><code>$(&apos;.tabs &gt; .surprise&apos;).on(&apos;click&apos;, function () {
    var htmlSurpriseTab = [
        &apos;&lt;div&gt;&apos;,
            &apos;&lt;button id=&quot;lucky-draw&quot;&gt;Lucky Draw &lt;/button&apos;,
        &apos; &lt;/div&gt;&apos;
    ].join(&apos;&apos;)
    $(&apos;.tab-panels &gt; .surprise&apos;).html(htmlSurpriseTab)

    // BTN READY
})
</code></pre><p>这意味着，我写的事件绑定代码需要写在 // BTN READY 处。这种深层的耦合看起来很不理想，我需要想办法解决它。</p>
<p>我想起来，我在阅读 jQuery 文档时看到有一种叫作 “事件委托” 的方法，可以在元素还未添加到页面之前就为它绑定事件。于是，我尝试这样来写：</p>
<pre><code>$(document.body).on(&apos;click&apos;, &apos;#lucky-draw&apos;, function () {
    BX.luckyDraw()
})
</code></pre><p>果然，我成功了！好事多磨啊，这个需求终于开心地上线了。</p>
<p>经过进一步的研究，我了解到 “事件委托” 的本质是利用了事件冒泡的特性。把事件处理函数绑定到容器元素上，当容器内的元素触发事件时，就会冒泡到容器上。此时可以判断事件的源头是谁，再执行对应的事件处理函数。由于事件处理函数是绑定在容器元素上的，即使容器为空也没有关系；只要容器的内容添加进来，整个功能就是准备就绪的。</p>
<p>虽然事件委托的原理听起来稍有些复杂，但由于 jQuery 对事件委托提供了完善的支持，我的代码并没有因此变得很复杂。</p>
<p>多想一步</p>
<p>经过这一番磨炼，我收获了很多经验值；同时，我也学会了更进一步去发现问题和思考问题。比如，在我们的网页，通常会有多个按钮，那为它们绑定事件的脚本代码可能就是这样的：</p>
<pre><code>$body = $(document.body)
$body.on(&apos;click&apos;, &apos;#lucky-draw&apos;, function () {
    BX.luckyDraw()
})

$body.on(&apos;click&apos;, &apos;#some-btn&apos;, function () {
    // do something...
})
$body.on(&apos;click&apos;, &apos;#another-btn&apos;, function () {
    // do something else...
})
</code></pre><p>我隐隐觉得这样不对劲啊！虽然这些代码可以正常工作，但每多一个按钮就要为 body 元素多绑定一个事件处理函数；而且根据直觉，这样一段段长得差不多的代码是需要优化的。因此，如果我可以把这些类似的代码整合起来，那不论是在资源消耗方面，还是在代码组织方面，都是有益的。</p>
<p>于是，我尝试把所有这些事件委托的代码合并为一次绑定。首先，为了实现合并，我需要为这些按钮找到共同点。很自然地，我让它们具有相同的 class：</p>
<pre><code>&lt;button class=&quot;action&quot; id=&quot;lucky-draw&quot;&gt;Lucky Draw &lt;/button
&lt;button class=&quot;action&quot; id=&quot;some-action&quot;&gt;Button &lt;/button
&lt;a href=&quot;#&quot; class=&quot;action&quot; id=&quot;another-action&quot;&gt;Link &lt;/a&gt;
&lt;a href=&quot;#&quot; class=&quot;action&quot; id=&quot;another-action-2&quot;&gt;Link &lt;/a&gt;
</code></pre><p>然后，我试图通过一次事件委托来处理所有这些按钮：</p>
<pre><code>$body.on(&apos;click&apos;, &apos;.action&apos;, function () {
    // WHEN CLICK ANY &apos;.action&apos;, WE COME HERE.
})
</code></pre><p>很显然，所有具有 action 类名的元素被点击后都会触发上面这个事件处理函数。那么，接下来，我们在这里区分一下事件源头，并执行对应的任务：</p>
<pre><code>$body.on(&apos;click&apos;, &apos;.action&apos;, function () {
    switch (this.id) {
        case &apos;lucky-draw&apos;:
            BX.luckyDraw()
            break
        case &apos;some-btn&apos;:
            // do something...
            break
        // ...
    }
})
</code></pre><p>这样一来，所有分散的事件委托代码就被合并为一处了。在这个统一的事件处理函数中，我们使用 ID 来区分各个按钮。</p>
<p>但 ID 有一些问题，由于同一页面上不能存在同名的元素，相信前端工程师们都对 ID 比较敏感，在日常开发中都尽量避免滥用。此外，如果多个按钮需要执行的任务相同，但它的 ID 又必须不同，则这些 ID 和它们对应的任务之间的对应关系就显得不够明确了。</p>
<p>于是，我改用 HTML5 的自定义属性来标记各个按钮：</p>
<pre><code>&lt;button class=&quot;action&quot; data-action=&quot;lucky-draw&quot;&gt;Lucky Draw &lt;/button&gt;
&lt;button class=&quot;action&quot; data-action=&quot;some-action&quot;&gt;Button &lt;/button&gt;
&lt;a href=&quot;#&quot; class=&quot;action&quot; data-action=&quot;another-action&quot;&gt;Link &lt;/a&gt;
&lt;a href=&quot;#&quot; class=&quot;action&quot; data-action=&quot;another-action-2&quot;&gt;Link &lt;/a&gt;
</code></pre><p>我在这里使用了 data-action 这个属性来标记各个按钮元素被点击时所要执行的动作。回过头看，由于各个按钮都使用了这个属性，它们已经具备了新的共同点，而 class 这个共同点就不必要了，于是我们的 HTML 代码可以简化一些：</p>
<pre><code>&lt;button data-action=&quot;lucky-draw&quot;&gt;Lucky Draw &lt;/button&gt;
&lt;button data-action=&quot;some-action&quot;&gt;Button &lt;/button&gt;
&lt;a href=&quot;#&quot; data-action=&quot;another-action&quot;&gt;Link &lt;/a&gt;
&lt;a href=&quot;#&quot; data-action=&quot;another-action-2&quot;&gt;Link &lt;/a&gt;
</code></pre><p>同时 JS 代码也需要做相应调整：</p>
<pre><code>$body.on(&apos;click&apos;, &apos;[data-action]&apos;, function () {
    var actionName = $(this).data(&apos;action&apos;)
    switch (actionName) {
        case &apos;lucky-draw&apos;:
            BX.luckyDraw()
            break
        case &apos;some-btn&apos;:
            // do something...
            break
        // ...
    }
})
</code></pre><p>我们的代码看起来已经挺不错了，但我已经停不下来了，还要继续改进。那个长长的 switch 语句看起来有点臃肿。通常优化 switch 的方法就是使用对象的键名和键值来组织这种对应关系。于是我继续改：</p>
<pre><code>var actionList = {
    &apos;lucky-draw&apos;: function () {
        BX.luckyDraw()
    },
    &apos;some-btn&apos;: function () {
        // do something...
    }
    // ...
}

$body.on(&apos;click&apos;, &apos;[data-action]&apos;, function () {
    var actionName = $(this).data(&apos;action&apos;)
    var action = actionList[actionName]

    if ($.isFunction(action)) action()
})
</code></pre><p>经过这样的调整，我发现代码的嵌套变浅了，而且按钮们的标记和它们要做的事情也被组织成了 actionList 这个对象，看起来更清爽了。</p>
<p>在这样的组织方式下，如果页面需要新增一个按钮，也很容易做扩展：</p>
<pre><code>// HTML
$body.append(&apos;a href=&quot;#&quot; data-action=&quot;more-action&quot;&gt;Link /a&gt;&apos;)

// JS
$.extend(actionList, {
    &apos;more-action&apos;: function () {
        // ...
    }
})
</code></pre><p>到这里，这一整套实践终于像那么回事了！</p>
<p>开源</p>
<p>我自己用这一套方法参与了很多项目的开发，在处理事件绑定时，它节省了我很多的精力。我忽然意识到，它可能还适合更多的人、更多的项目。那不妨把它开源吧！</p>
<p>于是我发布了 Action 这个项目。这个小巧的类库帮助开发者轻松随意地绑定点击事件，它使用 “动作” 这个概念来标记按钮和它被点击后要做的事情；它提供的 API 可以方便地定义一些动作：</p>
<pre><code>action.add({
    &apos;my-action&apos;: function () {
        // ...
    }
})
</code></pre><p>也可以手动触发已经定义的动作：</p>
<pre><code>action.trigger(&apos;my-action&apos;)
</code></pre><p>应用</p>
<p>Action 这个类库已经被移动 Web UI 框架 CMUI 采用，作为全局的基础服务。CMUI 内部的各个 UI 组件都是基于 Action 的事件绑定机制来实现的。我们这里以对话框组件为例，来看看 Action 在 CMUI 中的应用（示意代码）：</p>
<pre><code>CMUI.dialog = {
    template: [
        &apos;&lt;div class=&quot;dialog&quot;&gt;&apos;,
            &apos;&lt;a href=&quot;#&quot; data-action=&quot;close-dialog&quot;&gt;× &lt;/a&gt;&apos;,
            &apos;&lt;h2&gt;&lt;%= data.title %&gt; &lt;/h2&gt;&apos;,
            &apos;&lt;div class=&quot;content&quot;&gt;&lt;%- data.html %&gt; &lt;/div&gt;&apos;,
        &apos;&lt;/div&gt;&apos;
    ].join(&apos;&apos;),

    init: function () {
        action.add({
            &apos;close-dialog&apos;: function () {
                $(this).closest(&apos;.dialog&apos;).hide()
            }
        })
    },
    open: function (config) {
        var html = render(this.template, config)
        $(html).appendTo(&apos;body&apos;).show()
    }
}

CMUI.dialog.init()
</code></pre><p>只要当 CMUI.dialog.init() 方法执行后，对话框组件就准备就绪了。我们在业务中直接调用 CMUI.dialog.open() 方法、传入构造对话框所需要的一些配置信息，这个对话框即可创建并打开。</p>
<p>大家可以发现，在构造对话框的过程中，我们没有做任何事件绑定的工作，对话框的关闭按钮就自然具备了点击关闭功能！原因就在于关闭按钮</p>
<pre><code>(&lt;a href=&quot;#&quot; data-action=&quot;close-dialog&quot;&gt;×&lt;/a&gt;)
</code></pre><p>自身已经通过 data-action 属性声明了它被点击时所要执行的动作（’close-dialog’），而这个动作早已在组件初始化时（CMUI.dialog.init()）定义好了。</p>
<p>结语</p>
<p>希望本文对你有所启发，也希望 Action 能在实际开发中帮到你。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="飞来小侠" />
          <p class="site-author-name" itemprop="name">飞来小侠</p>
           
              <p class="site-description motion-element" itemprop="description">依法不依人，依义不依语。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">58</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/flyingliu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/5872146656" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/guolaiwan/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      豆瓣
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/liu-fei-lai/activities" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">飞来小侠</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Pisces
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://ananfo.disqus.com/count.js" async></script>
    

    

  




	





  










  





  

  

  

  

  

  

</body>
</html>
