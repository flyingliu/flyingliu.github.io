<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="依法不依人，依义不依语。">
<meta property="og:type" content="website">
<meta property="og:title" content="如是我闻">
<meta property="og:url" content="http://flyingliu.github.io/page/5/index.html">
<meta property="og:site_name" content="如是我闻">
<meta property="og:description" content="依法不依人，依义不依语。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="如是我闻">
<meta name="twitter:description" content="依法不依人，依义不依语。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://flyingliu.github.io/page/5/"/>





  <title>如是我闻</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">如是我闻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">色即是空，空即是色</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-17-study-backbone/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-17-study-backbone/" itemprop="url">Backbone的学习[一]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-17-study-backbone/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-17-study-backbone/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这个例子是仿照todo去实现一些任务的。我想慢慢去扩展它，争取把backdone常用的概念能跑一遍。</p>
<p><a href="/src/demos/study-backbone.html">实例</a></p>
<p>backbone中的创建视图</p>
<h1 id="用el-id-tagName-className-attributes的区别"><a href="#用el-id-tagName-className-attributes的区别" class="headerlink" title="用el,id,tagName,className,attributes的区别"></a>用el,id,tagName,className,attributes的区别</h1><pre><code>&lt;div title=&quot;列表&quot; style=&quot;color:red&quot; id=&quot;list&quot; class=&quot;listview&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var ListView = Backbone.View.extend({
        el : &apos;#list&apos;
    });
     var listview = new ListView();
&lt;/script&gt;
</code></pre><p><strong>当dom选择器已经存在时用 <code>el</code> 指定对应的DOM对象</strong></p>
<p>在这个例子中，我们定义了一个ListView视图类，它继承自Backbone.View，我们通过new关键字实例化一个ListView对象。</p>
<p>在定义ListView时，我们设置了el属性，它应该是一个字符串形式的DOM选择器，但视图对象在实例化时，会在内部通过这个选择器获取对应的DOM对象，并重新存放在el属性中。因此我们可以在视图的内部通过this.el来访问所关联的DOM对象。</p>
<p>每个视图对象都会关联一个DOM对象，视图中所有操作都限定在这个DOM对象之内，这样做可以便于视图界面的控制（如渲染、隐藏和移除等），同时能提高查找视图内子元素的效率。</p>
<p>上面的例子中，id为list的标签是我们事先准备好的，在定义ListView时可以直接通过#list选择器来引用它，但实际开发时这些DOM可能是动态生成的，至少在定义视图类时它们还不存在。此时，我们可以通过另一种方式来设置视图的DOM对象：</p>
<p><strong>当dom选择器在定义视图类还不存在时用 <code>tagName</code> </strong></p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var ListView = Backbone.View.extend({
      tagName : &apos;div&apos;,
      className : &apos;listview&apos;,
       id : &apos;list&apos;,
       attributes : {
           title : &apos;列表&apos;,
           style : &apos;color:red&apos;
      },
      render : function() {
          this.el.innerHTML = &apos;Hello World!&apos;;
           document.body.appendChild(this.el);
       }
    });
    var listview = new ListView();
    listview.render();
&lt;/script&gt;
</code></pre><p>运行这个例子，页面上输出了一段红色的文字：Hello World!。如果你通过Firebug等工具查看当前的DOM结构，你能看到body结束标签之前多了这样一段：</p>
<pre><code>&lt;div title=&quot;列表&quot; style=&quot;color:red&quot; id=&quot;list&quot; class=&quot;listview&quot;&gt;Hello World!&lt;/div&gt;
</code></pre><p>这段标签是视图对象在实例化时根据<code>tagName</code>、<code>className</code>、<code>id</code>和<code>attributes</code>属性自动创建的，结合我们的代码，你可以很清晰地看出：</p>
<ul>
<li><p>tagName表示新标签的名称（如果没有设置，则默为div标签）</p>
</li>
<li><p>className对应标签的class样式属性</p>
</li>
<li><p>id对应标签的id属性</p>
</li>
</ul>
<p>这3个是最常见的HTML属性，你可以在定义视图类时直接设置它们，如果还需要设置更多的属性，可以通过attributes属性来定义。</p>
<p>你可能注意到，我们还定义了一个render()方法，在创建ListView实例之后，我们调用该方法将新建的标签添加到页面尾部，否则它只会存储在el属性中，而不会被显示。</p>
<p>上面介绍的两种创建方式，是在两种不同的场景中使用，分别是对已经存在的DOM创建视图，和创建视图时同时创建新的DOM，因此你不应该不会同时使用到它们。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-22-gitcafe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-22-gitcafe/" itemprop="url">用gitcafe托管个人站点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-22-gitcafe/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-22-gitcafe/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>国内访问github时好时坏，很令人捉急。不得不诅咒万恶的”墙”。这几天偶然发现一个可以提供类github的pages服务的国内站点。提到的人比较多尤其是可以和github,hugo配套使用。试着做了一下测试。以后可以考虑放在这个上面。</p>
<p><a href="http://ananfo.gitcafe.io/" target="_blank" rel="external">测试页Demo</a></p>
<p><a href="https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9#wiki" target="_blank" rel="external">帮助文档</a></p>
<p><a href="https://gitcafe.com/" target="_blank" rel="external">gitcafe官方网站</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-21-use-hugo-create-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-21-use-hugo-create-blog/" itemprop="url">使用hugo搭建个人博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-21-use-hugo-create-blog/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-21-use-hugo-create-blog/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>截至目前我写这篇博客，用的是jekyll。jekyll文档很多，虽然配置稍微有点麻烦，但对于折腾过nodejs的前端来说，勉强可以应付。目前来说我觉得jekyll还是很完美的。当然这是在我博文比较少的情况，我也在担忧如果哪天我的博文躲起来是不是编译就要花费不少时间。文件多了也不好管理。jekyll应该有个归档功能，把发布的文章能分类处理，不需要每次都重新编译所有文章。当然最好的把速度提上去，那所有的问题都不是问题了。</p>
<p>最近接触的静态服务器来搭建博客的工具挺多。用过一阵子harpjs，对于本地我做静态站点确实很好用，集成了如jade,sass,coffeescript等编译工具。不需要配置文件，这些统统搞定，对于定制要求不高的话，确实是一个不二选择。我还在heroku上试着搭建了几个小站点，不用本地编译导出就能用，感觉很方便。但是对于经常写文字，敲代码还是有点不太方便。</p>
<p>未雨绸缪，我决定还是用用hugo这个由go语言搭建的工具。据说唯一的缺点就是太快了，太快了，太快了。重要的事情要说三遍的。说说步骤：</p>
<p>Hugo官方主页：<a href="https://gohugo.io/" target="_blank" rel="external">https://gohugo.io/</a></p>
<p>一. <a href="https://github.com/spf13/hugo/releases" target="_blank" rel="external">下载hugo</a>,支持多个系统平台，只是下载地址好像在amazonaws.com上，有被墙了。国内的局域网挺操蛋的。</p>
<p>二. 解压文件，都不用安装，设置下系统路径就OK了。在cmd中设置路径运行：</p>
<pre><code>hugo new site /path/site
</code></pre><p>三. 进入site目录就可以看到如下目录结构了。<br>    archetypes/<br>    content/<br>    layouts/<br>    static/<br>    config.toml</p>
<p>简要介绍一下，config.toml是网站的配置文件，这是一个TOML文件，全称是Tom’s Obvious, Minimal Language，这是它的作者GitHub联合创始人Tom Preston-Werner 觉得YAML不够优雅，捣鼓出来的一个新格式。如果你不喜欢这种格式，你可以将config.toml替换为YAML格式的config.yaml，或者json格式的config.json。hugo都支持。</p>
<p>content目录里放的是你写的markdown文章，layouts目录里放的是网站的模板文件，static目录里放的是一些图片、css、js等资源。</p>
<p>创建一个页面：</p>
<pre><code>hugo new about.md
</code></pre><p>如果是博客日志，最好将md文件放在content的post目录里。</p>
<pre><code>hugo new post/first.md
</code></pre><p>编辑刚才新建的页面：</p>
<pre><code>+++
date = &quot;2015-01-08T08:36:54-07:00&quot;
draft = true
title = &quot;first&quot;
+++

### Hello Hugo
</code></pre><p>OK，刚才的about.md也有内容，该看看最后的效果了。然后你屁颠屁颠的使用hugo server启动，打开浏览器里一看，发现毛都没有！这是肿么了！</p>
<p>这是Hugo对初学者非常不友好的地方，默认生成的网站是没有任何皮肤模板的。为了看看第一个写的示例，还得去Github上把一个网页模板下载下来。如果你网络够好，网速够快，你可以在刚才的目录将Hugo官方的所有模板都下载下来：</p>
<pre><code>git clone --recursive https://github.com/spf13/hugoThemes themes
</code></pre><p>我尝试过，也失败过，且从未成功一次性将所有的模板下载下来。所以，我们还是老老实实只下载其中一个模板来看看效果吧：</p>
<pre><code>cd themes
git clone https://github.com/spf13/hyde.git
</code></pre><p>启动本地调试：</p>
<pre><code>hugo server --theme=hyde --buildDrafts --watch
</code></pre><p>OK,大功告成了，现在可以启用浏览器查看了。</p>
<p>–watch或者-w 选项打开的话，将会监控到文章的改动从而自动去刷新浏览器，不需要自己手工去刷新浏览器，非常方便。</p>
<p>如果你看了上面的说明已经有冲动去试一试Hugo了，我的目的也算达到了，接下来你需要的只是查看官方的说明文档就够了，所以具体的一些设置我就不重复了。</p>
<p>官方文档：<a href="https://gohugo.io/overview/introduction/" target="_blank" rel="external">https://gohugo.io/overview/introduction/</a></p>
<p>皮肤列表：<a href="https://github.com/spf13/hugoThemes" target="_blank" rel="external">https://github.com/spf13/hugoThemes</a></p>
<p>常用文档：</p>
<ul>
<li><a href="https://gohugo.io/overview/configuration/" target="_blank" rel="external">Configuring Hugo</a></li>
<li><a href="https://gohugo.io/content/front-matter/" target="_blank" rel="external">Front Matter</a></li>
<li><a href="https://gohugo.io/extras/menus/" target="_blank" rel="external">Menus</a></li>
<li><a href="https://gohugo.io/templates/variables/" target="_blank" rel="external">Template Variables</a></li>
<li><a href="https://gohugo.io/tutorials/github-pages-blog/" target="_blank" rel="external">Hosting on GitHub Pages</a></li>
</ul>
<h1 id="Hugo发布时要注意的地方"><a href="#Hugo发布时要注意的地方" class="headerlink" title="Hugo发布时要注意的地方"></a>Hugo发布时要注意的地方</h1><ol>
<li><p>生产环境和开发环境的区别，server命令不加参数<code>baseUrl</code>时输出的链接全是localhost:1313的绝对地址，所以push前需要删除public文件夹，然后<code>hugo -t themeName</code>就行了；如果配置文件制定了theme,那么直觉 <code>hugo</code> 命令就行了。</p>
</li>
<li><p>front-matter内容中url的值最好符合Jekyll的格式，这与config.toml中的permalinks相关联，详细设置在 <a href="http://gohugo.io/content/organization/" target="_blank" rel="external">http://gohugo.io/content/organization/</a></p>
</li>
<li><p>post的md文件编码必须是utf-8的，要不乱码</p>
</li>
</ol>
<p>分享个cmd文件<code>hugo-n</code>用于快速新建一篇博文()</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">rem 用法：`hugo-n a-post-title-without-ext-md`</div><div class="line">@echo off</div><div class="line">for /f &quot;tokens=1-3 delims=/ &quot; %%a in (&apos;date /t&apos;) do (set mydate=%%a-%%b-%%c)</div><div class="line">set postname=post\%mydate%-%1.md</div><div class="line">if exist content\%postname% (</div><div class="line">echo 文件已存在，按任意键退出 &amp; pause&gt;nul &amp; exit ) else (</div><div class="line">hugo new %postname%</div><div class="line">gvim content\%postname% )</div></pre></td></tr></table></figure>
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-20-regexp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-20-regexp/" itemprop="url">正则表达式学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-20-regexp/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-20-regexp/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp" target="_blank" rel="external">JavaScript RegExp 对象</a></p>
<p>来自php中的正则：</p>
<ol>
<li><p>定界符</p>
<p> 一般用 / / 作为正则的定界符</p>
</li>
<li><p>原子<br> 原子是正则表达式的基本的单位，一个正则表达式必须具有至少一个原子。</p>
<ol>
<li>所有打印和非打印的字符</li>
<li>. * ？ +  ( ) &lt; &gt; 等有意思的字符可以用 “\” 转义字符转义</li>
<li>\d 表示十进制的数字   [0-9]<br>\D 表示任意一个除了数字外的字符 [^0-9]<br>\s 表示任意一个空白字符，空格\n\r\t\f<br>\S 表示任意一个非空白字符<br>\w 表示任意一个字 a-zA-Z0-9_<br>\W 表示任意一个非字，除了a-zA-Z0-9_的符号<br>.  查找单个字符，除了换行和行结束符。</li>
<li>自己定义的原子[].如 [1-9]<br> [^abc] 表示取反</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>元字符</p>
<p> 元字符是用来修饰原子的，不可以单独出现</p>
<p> | 量词        | 描述                                     |<br> | ————|:—————————————-:|<br> | n+          | 匹配任何包含至少一个 n 的字符串。        |<br> | n*          | 匹配任何包含零个或多个 n 的字符串。      |<br> | n?          | 匹配任何包含零个或一个 n 的字符串。      |<br> | n{X}        |  匹配包含 X 个 n 的序列的字符串。        |<br> | n{X,Y}      |  匹配包含 X 或 Y 个 n 的序列的字符串。   |<br> | n{X,}       | 匹配包含至少 X 个 n 的序列的字符串。     |<br> | n$          | 匹配任何结尾为 n 的字符串。              |<br> | ^n          | 匹配任何开头为 n 的字符串。              |<br> | ?=n         | 匹配任何其后紧接指定字符串 n 的字符串。  |<br> | ?!n         | 匹配任何其后没有紧接指定字符串 n 的字符串|</p>
</li>
<li><p>模式修正符</p>
</li>
</ol>
<p> 方法一：以字面量形式来创建</p>
<p>格式为/pattern/flags;其中pattern（模式）为任何简单或者复杂的表达式，可以包括字符类，限定符，分组，向前查找以及反向引用。每个正则表达式都可以有一个或者多个标识（flags），用以表明表达式的行为。正则表达式的匹配模式支持下列三个标识：</p>
<p><strong>g:（global） 全局模式，</strong>即模式将应用于所有的字符串，而非发现第一个匹配项时立即停止；</p>
<p><strong>i: (case-insensitive)</strong> 表示不区分大小写模式</p>
<p><strong>m: (multiline)表示多行模式，</strong>即在文本的末尾时会继续查找下一行是否存在于模式匹配的项</p>
<p>用法如下：</p>
<p>匹配字符串所有的“at”:</p>
<pre><code>var pattern1 = /at/g;
匹配字符串第一个“at”:

var pattern2 = /[bc]at/i;
</code></pre><p>方法二：使用RegExp构造函数来创建</p>
<p>它接受两个参数： 一个是匹配的字符串模式，另一个是可选的标识字符串。</p>
<p>用法如下：</p>
<p>匹配第一个cat或者bat,不区分大小写:</p>
<pre><code>var pattern = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);
</code></pre><p>2.由于RegExp构造函数的模式的参数是字符串，所以某些情况下要对字符进行双重转义</p>
<p>所有元字符都要进行双重转义，那么那些已经转义过的字符也是如此。例如：\n（字符\在字符串中通常被转义为\，而在正则表达式字符串中会变成\\）。下面给出一些模式，左边是字面量，右边是RegExp的 </p>
<pre><code>/\[bc\]at/;        &quot;\\[bc\\]at&quot;;

/\.at/;       &quot;/\\.at/&quot;;

/name\/age/;       &quot;/name\\/age/&quot;;

/\d.\d{1,2}/;       &quot;\\d.\\d{1,2}&quot;;

/\w\\hello\\123/;     &quot;\\w\\\\hello\\\\123&quot;;
</code></pre><p>3.字面量和构造函数创建正则表达式的区别</p>
<p>在ES3中 ，正则表达式字面量始终会共享一个RegExp实例，而使用构造函数创建的每一个新的RegExp实例都是一个新的实例。 但是ES5之后，两者是没有这种区别的 。</p>
<p>比如下面例子：</p>
<pre><code>var re = null,
i;
for(var i = 0; i &lt; 10; i++) {
re = /cat/g;
console.log(re.test(&quot;catastrophe&quot;));
}

for(var i = 0; i &lt; 10; i++) {
re = new RegExp(&quot;cat&quot;, &quot;g&quot;);
console.log(re.test(&quot;catastrophe&quot;));
}
</code></pre><p>4.RegExp的实例属性</p>
<p>RegExp每个实例都具有下面的属性：</p>
<p>global: 布尔值，表示是否设置了g标识</p>
<p>ignoreCase: 布尔值，表示是否设置了i标识</p>
<p>multiline:布尔值，表示是否设置了m标识 </p>
<p>lastIndex: 整数，表示开始搜索下个匹配项的字符串的位置，从0开始</p>
<p>source: 正则表达式的字符串表示，按照字面量的形式而非传入构造函数中的字符串模式返回</p>
<pre><code>ar pattern1 = /\[bc\]at/i;
console.log(pattern1.global);//false
console.log(pattern1.ignoreCase);//true
console.log(pattern1.multiline);//false
console.log(pattern1.lastIndex);//0
console.log(pattern1.source); ///\[bc\]at/i

var pattern2 = new RegExp(&quot;\\[bc\\]at&quot;, &quot;i&quot;);
console.log(pattern2.global);
console.log(pattern2.ignoreCase);
console.log(pattern2.multiline);
console.log(pattern2.lastIndex);
console.log(pattern2.source);
</code></pre><p>我们注意到，第二个模式是使用构造函数，但是他们的source属性是相同的。可见，source属性保存的是规范形式的字符串，即字面量形式所使用的字符串。</p>
<p>5.捕获组</p>
<p>使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个捕获组会自动拥有一个组号，规则是： 从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推 。 </p>
<p>比如下面的例子：</p>
<pre><code>var pattern = /mom (and dad (and baby)?)?/gi;
</code></pre><p>6.正则表达式的实例方法</p>
<p>1.exec(String testString);</p>
<p>该方法是专门为捕获组而设计的。它接受一个参数，即要应用到模式的字符串，然后返回包含第一个匹配项信息的数组；或者没有匹配项的情况下返回null.返回的数组虽然是Array实例，单包含两个额外的属性： index和input.其中index表示匹配项出现在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。（如果模式中没有捕获组，则该数组只包含一项）</p>
<pre><code>var text = &quot;mom and dad and baby&quot;;
var pattern = /mom (and dad (and baby)?)?/gi;
var matches = pattern.exec(text);
console.log(matches.index);   //0
console.log(matches.input); //mom and dad and baby
console.log(matches[0]); //mom and dad and baby
console.log(matches[1]); //and dad and baby
console.log(matches[2]);  //and baby
</code></pre><p>对于exec方法而言，即使在模式中设置了全局标识（g）,它每次也只会返回一个匹配项，在不设置全局标识的情况下，在同一个字符串上多次调用exec将会返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec则会在字符串中继续查找新的匹配项。如下面的例子：</p>
<pre><code>var text = &quot;cat, bat, sat, fat&quot;;
var pattern1 = /.at/;

var matches = pattern1.exec(text);
console.log(pattern1.lastIndex); //0
console.log(matches.index);    //0
console.log(matches[0]);    `//cat

matches = pattern1.exec(text);
console.log(pattern1.lastIndex);    //0
console.log(matches.index);    //0
console.log(matches[0]);    //cat

var pattern2 = /.at/g;

matches = pattern2.exec(text);
console.log(pattern2.lastIndex); //3
console.log(matches.index);    //0
console.log(matches[0]);    //cat

matches = pattern2.exec(text);
console.log(pattern2.lastIndex); //8
console.log(matches.index);    //5
console.log(matches[0]);    //bat
</code></pre><p>2.test(String testString)</p>
<p>该方法接受一个字符串参数。在模式与该参数匹配的情况下，返回true，否则，返回false。要想知道目标字符串是否和某个字符串匹配，但不需要其文本内容的情况下，使用这个方法非常方便。因此，test经常用在if语句里。</p>
<p>如下面的例子：</p>
<pre><code>var text = &quot;000-00-0000&quot;;
var pattern = /\d{3}-\d{2}-\d{4}/;

if(pattern.test(text)) {
console.log(&quot;The pattern is matched&quot;);
}
RegExp实例继承的toLocaleString和toString方法都会返回正则表达式的字面量；与创建正则表达式的方式无关。例如：

var pattern = new RegExp(&quot;\\[bc\\]at&quot;, &quot;gi&quot;);
console.log(pattern.toString());
console.log(pattern.toLocaleString());

输入都是：/\[bc\]at/gi
</code></pre><p>7.RegExp构造函数属性</p>
<p>RegExp构造函数包含了一些属性（称为静态属性）。这些属性使用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性名的另一个特殊之处，就是可以通过两种方式访问他们。换句话说，这些属性分别有个长属性名和一个短属性名。下面给出了RegExp的构造函数的属性：</p>
<p>input                 $_  最近一次要匹配的字符串</p>
<p>lastMatch             $&amp; 最近一次匹配项</p>
<p>lastParen             $+ 最近一次匹配的捕获组</p>
<p>leftContext           $` input字符串中lastMatch之前的文本</p>
<p>rightContext          $’ input字符串中 lastMatch之后的文本</p>
<p>multiline             $* 布尔值，表示是否所有表达式都使用多行模式</p>
<p>例子如下：</p>
<pre><code>var text = &quot;this has been a short summer&quot;;
var pattern = /(.)hort/g;

if(pattern.test(text)) {
console.log(RegExp.input); //this has been a short summer
console.log(RegExp.leftContext); //this has been a 
console.log(RegExp.rightContext);// short summer
console.log(RegExp.lastMatch);//short
console.log(RegExp.lastParen);//s
console.log(RegExp.multiline);//false;
}
</code></pre><p>如前所述，例子使用的长属性名都可以使用相应的短数学迷来代替。只不过这些短属性大多都不是有效的ES标识符， 因此必须通过方括号语法来访问他们 。如下所示：</p>
<pre><code>var text = &quot;this has been a short summer&quot;;
var pattern = /(.)hort/g;

if(pattern.test(text)) {
console.log(RegExp.$_);
console.log(RegExp[&quot;$`&quot;]);
console.log(RegExp[&quot;$&apos;&quot;]);
console.log(RegExp[&quot;$&amp;&quot;]);
console.log(RegExp[&quot;$+&quot;]);
console.log(RegExp[&quot;$*&quot;]);
}
</code></pre><p>RegExp构造函数除了以上几个属性之外，还有多达9个用于存储捕获组的构造韩事故属性。访问这些属性的语法是RegExp.$1, RegExp.$2…RegExp.$9，分别用于存储第一，2…9个匹配的捕获组。在调用exec或者test函数时，这些属性都会自动填充。然后，我们可以像下面这样使用他们。</p>
<pre><code>var text = &quot;this has a short summer&quot;;
var pattern = /(..)or(.)/g;

if(pattern.test(text)) {
console.log(RegExp.$1); //sh
console.log(RegExp.$2); //t
console.log(RegExp.$3); //（空字符串）
}
</code></pre><script>
  var str = "this is good idea at my cat. but this is gooat! 9527 "
  var reg = /[0-9]/g

  var r = reg.test(str);
  console.log(r);
  str.match(reg);

</script>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2014-07-25-use-my-domain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2014-07-25-use-my-domain/" itemprop="url">谢赫六法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2014-07-25-use-my-domain/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2014-07-25-use-my-domain/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>气韵生动</li>
<li>骨法用笔</li>
<li>应物象形</li>
<li>随类赋彩</li>
<li>经营位置</li>
<li>传移模写</li>
</ul>
<p>谢赫的六法论是怎样论述的，历代又是怎样理解与发展的，这需要对原文进行必要的释义。谢赫原文和古代的辗转传抄是不标点断句的，后人点句不同，六法的意思也就有了一些区别。但不论哪种点句法，所包涵的基本内容却是大体一致的。</p>
<p>对六法原文的标点断句，一般是“六法者何？一气韵生动是也，二骨法用笔是也，三应物象形是也，四随类赋彩是也,五经营位置是也,六传移模写是也。” 这种标法主要是根据唐代美术理论家张彦远《历代名画记》的记述：“昔谢赫云：画有六法：一曰气韵生动，二曰骨法用笔，三曰应物象形，四曰随类赋彩，五曰经营位置，六曰传移模写。”</p>
<p>今人钱钟书《管锥编》第四册论及这段文字，认为应作如下读法，方才符合谢赫原意与古文法：“六法者何？一、气韵，生动是也；二、骨法，用笔是也；三、应物，象形是也；四、随类，赋彩是也；五、经营，位置是也；六、传移，模写是也。”</p>
<hr>
<p>苏轼的《题二王书》中的：“笔成冢，墨成池。不及羲之即献之；笔秃千管，墨磨万锭，不作张芝作索靖。”</p>
<h1 id="“草书热”："><a href="#“草书热”：" class="headerlink" title="“草书热”："></a>“草书热”：</h1><p>　　专用为务，钻坚弥高，忘其疲劳， 夕惕不息，仄不暇食，十日一笔，月数丸墨。领袖如皂，唇齿常墨。虽处众座，不遑谈戏，展指画地，以草刿壁，臂穿皮刮，指爪摧折，见腮出血，犹不休辍。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-10-01-git-commend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-10-01-git-commend/" itemprop="url">git命令行</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-10-01-git-commend/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-10-01-git-commend/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>git命令用得不是很熟，备份下。</p>
<ol>
<li>添加远程仓库地址</li>
</ol>
<p>开始用命令行创建一个新的存储库</p>
<pre><code>echo # gittest &gt;&gt; README.md
git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin git@github.com:flyingliu/gittest.git
git push -u origin master
</code></pre><p>推送到现有的存储库</p>
<pre><code>// git subtree add --prefix=public git@github.com:flyingliu/gittest.git gh-pages --squash
// git subtree pull --prefix=public git@github.com:flyingliu/gittest.git gh-pages
// git subtree push --prefix=public git@github.com:flyingliu/gittest.git gh-pages
// git submodule add git@github.com:flyingliu/flyingliu.github.io.git public
// git submodule pull git@github.com:flyingliu/flyingliu.github.io.git public
git remote add origin git@github.com:flyingliu/flyingliu.github.io.git
git push -u origin master
</code></pre><p>注意点：为什么push时加 <code>-u</code> 参数</p>
<p>简单来说使用git push -u origin master以后就可以直接使用不带别的参数的git pull从之前push到的分支来pull。</p>
<hr>
<p>位到上一个提交前的状态 git reset –hard 同时删除提交</p>
<pre><code>git reset --hard HEAD^
</code></pre><hr>
<h1 id="给git命令起别名"><a href="#给git命令起别名" class="headerlink" title="给git命令起别名"></a>给git命令起别名</h1><p>我们可以在 ~/.gitconfig 文件里面进行别名设置，即加上下面这几行</p>
<pre><code>[alias]
  st = status
  ci = commit
  br = branch
  co = checkout
  df = diff
</code></pre><p>也可以用下面命令行添加</p>
<pre><code>git config --global alias.l   &quot;log --color --graph --decorate --pretty=oneline --abbrev-commit&quot;
git config --global alias.l0  &quot;log --color --graph --decorate --pretty=oneline --abbrev-commit -U0&quot;
git config --global alias.la  &quot;log --color --graph --decorate --pretty=oneline --abbrev-commit --all&quot;
git config --global alias.lb  &quot;log --color --graph --decorate --pretty=oneline --abbrev-commit --all --simplify-by-decoration&quot;
git config --global alias.lg  &quot;log --color --graph --decorate&quot;
git config --global alias.dl  &quot;log --date-order --color --graph --decorate --pretty=oneline --abbrev-commit&quot;
git config --global alias.dla  &quot;log --date-order --color --graph --decorate --pretty=oneline --abbrev-commit --all&quot;
git config --global alias.dlb  &quot;log --date-order --color --graph --decorate --pretty=oneline --abbrev-commit --all --simplify-by-decoration&quot;
git config --global alias.dlg  &quot;log --date-order --color --graph --decorate&quot;


git config --global alias.d   &quot;diff --color&quot;
git config --global alias.dc  &quot;diff --color --cached&quot;
git config --global alias.d0  &quot;diff --color --unified=0&quot;
git config --global alias.ci  &quot;commit --verbose&quot;
git config --global alias.co  &quot;checkout&quot;
git config --global alias.tr  &quot;checkout --track&quot;
git config --global alias.s   &quot;status --short&quot;
git config --global alias.st  &quot;status&quot;
</code></pre><hr>
<h1 id="Git-fetch和git-pull的区别"><a href="#Git-fetch和git-pull的区别" class="headerlink" title="Git fetch和git pull的区别"></a>Git fetch和git pull的区别</h1><p>Git中从远程的分支获取最新的版本到本地有这样2个命令：</p>
<p>一. git fetch：相当于是从远程获取最新版本到本地，不会自动merge.</p>
<pre><code>git fetch origin master
git log -p master..origin/master
git merge origin/master
</code></pre><p>以上命令的含义：首先从远程的origin的master主分支下载最新的版本到origin/master分支上,然后比较本地的master分支和origin/master分支的差别,最后进行合并.</p>
<p>上述过程其实可以用以下更清晰的方式来进行：</p>
<pre><code>git fetch origin master:tmp
git diff tmp
git merge tmp
</code></pre><p>从远程获取最新的版本到本地的test分支上,之后再进行比较合并</p>
<p>二. <code>git pull</code>：相当于是从远程获取最新版本并merge到本地</p>
<pre><code>git pull origin master
</code></pre><p>上述命令其实相当于<code>git fetch</code> 和 <code>git merge</code></p>
<p>在实际使用中，git fetch更安全一些,因为在merge前，我们可以查看更新情况，然后再决定是否合并.</p>
<p>三. 删除远程分支与本地分支</p>
<pre><code>git branch -D :branch-name      //删除本地分支   
git push origin :branch-name    //删除远程分支
</code></pre><hr>
<h1 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h1><ol>
<li>git中分支名与文件名最好不要重名，以免引起不必要的麻烦</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-08-jekyll-serve/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-08-jekyll-serve/" itemprop="url">jekyll常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-08-jekyll-serve/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-08-jekyll-serve/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://jekyll.bootcss.com/docs/usage/" target="_blank" rel="external">jekyll中文文档</a></p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Jekyll 同时也集成了一个开发用的服务器，可以让你使用浏览器在本地进行预览。</p>
<pre>
jekyll serve
# => 一个开发服务器将会运行在 http://localhost:4000/

$ jekyll serve --detach
# => 功能和`jekyll serve`命令相同，但是会脱离终端在后台运行。
#    如果你想关闭服务器，可以使用`kill -9 1234`命令，"1234" 是进程号（PID）。
#    如果你找不到进程号，那么就用`ps aux | grep jekyll`命令来查看，然后关闭服务器。[更多](http://unixhelp.ed.ac.uk/shell/jobz5.html).

$ jekyll serve --watch
# => 和`jekyll serve`相同，但是会查看变更并且自动再生成。
</pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-18-backbone-todos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-18-backbone-todos/" itemprop="url">Backbone例子todos</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-18-backbone-todos/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-18-backbone-todos/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这个例子发现原来太经典了，增删改查都有了。</p>
<p>对照经典的实例代码，做下笔记。</p>
<p><a href="/src/demos/todos.html">demo地址</a></p>
<p><a href="/src/demos/todoa.html">便利贴</a></p>
<h1 id="backbone中的listenTo与on的区别"><a href="#backbone中的listenTo与on的区别" class="headerlink" title="backbone中的listenTo与on的区别"></a>backbone中的listenTo与on的区别</h1><p><strong>使用情景区别</strong></p>
<p>listenTo用于监听自身已外的对象</p>
<p>on用于监听自身</p>
<p>listenTo和on中的回调函数里的this的区别</p>
<pre><code>listener.listenTo(object, &apos;eventName&apos;, function(){
    //此处的this指向listener
})
object.on(&apos;eventName&apos;, function(){
    //此处的this指向object
})
object.on(&apos;eventName&apos;, function(){
    //此处的this指向context
}, context)
</code></pre><p><strong>触发顺序</strong></p>
<p>当存在同名事件时,会按定义顺序执行,on和listenTo定义的事件会处在同一队列中</p>
<p>若监听了all事件,则触发任意事件都将会在执行完相应回调后执行all事件的回调,  all事件的监听会传递一个参数,该参数为事件名字</p>
<pre><code>var a = {
        type: &quot;I&apos;m listening&quot;
    },
    b = {
        type: &quot;I&apos;m listened&quot;
    };
_.extend(a, Backbone.Events);
_.extend(b, Backbone.Events);
b.on(&apos;onNoContext&apos;, function() {
    console.log(&apos;trigger onNoContext&apos;);
    console.log(this.type);
});
b.on(&apos;onContext&apos;, function() {
    console.log(&apos;trigger onContext&apos;);
    console.log(this.type);
}, a);
a.listenTo(b, &apos;listened&apos;, function() {
    console.log(&apos;trigger listened&apos;);
    console.log(this.type);
});
b.on(&apos;all&apos;, function() {
    console.log(&apos;trigger on all&apos;);
});
a.listenTo(b, &apos;all&apos;, function() {
    console.log(&apos;trigger listen all&apos;);
});
console.log(&apos;###b.trigger(&quot;all&quot;)###&apos;);
b.trigger(&apos;all&apos;);
console.log(&apos;###b.trigger(&quot;onNoContext&quot;)###&apos;);
b.trigger(&apos;onNoContext&apos;);
console.log(&apos;###b.trigger(&quot;onContext&quot;)###&apos;);
b.trigger(&apos;onContext&apos;);
console.log(&apos;###b.trigger(&quot;listened&quot;)###&apos;);
b.trigger(&apos;listened&apos;);
</code></pre><p>运行结果:</p>
<pre><code>###b.trigger(&quot;all&quot;)###
trigger on all
trigger listen all
trigger on all
trigger listen all
###b.trigger(&quot;onNoContext&quot;)###
trigger onNoContext
I&apos;m listened
trigger on all
trigger listen all
###b.trigger(&quot;onContext&quot;)###
trigger onContext
I&apos;m listening
trigger on all
trigger listen all
###b.trigger(&quot;listened&quot;)###
trigger listened18 I&apos;m listening
rigger on all
trigger listen all
</code></pre><hr>
<h1 id="Backbone-js-event-bind-新功能-listenTo-and-stopListening"><a href="#Backbone-js-event-bind-新功能-listenTo-and-stopListening" class="headerlink" title="Backbone.js event bind 新功能 listenTo and stopListening"></a>Backbone.js event bind 新功能 listenTo and stopListening</h1><p>以前在 Backbone View 寫法都是像底下這樣</p>
<pre><code>initialize: function() {
    if (this.model) {
        this.model.on(&quot;change&quot;, this.render, this);
    }
},

render: function () {
}
</code></pre><p>上面我們可以看到當 model 有任何改變時，就會 trigger render function，這是最簡單的寫法，當我們移除 View 的時候，此事件就會跟著消失，但是如果是 Reference 到其他 Object 物件方法，如底下 myObject.on(“some:event”, anotherObject.someHandler); 當 anotherObject 物件被移除時，這時 myObject 還是綁定事件在 anotherObject 上面，這就會出現 zombie objects in JavaScript apps，當然這是有解法的，我們只需要在移除 anotherObject 之前呼叫底下程式碼:  myObject.off(“some:event”, anotherObject.someHandler); 透過上面解法，我們可以將 Backbone.js View 寫法改成底下:</p>
<pre><code>Backbone.View.extend({
    initialize: function(){
        this.model.on(&quot;change:foo&quot;, this.doStuff, this);
    },

    doStuff: function(foo){
        // do stuff in response to &quot;foo&quot; changing
    },

    remove: function(){
        this.model.off(&quot;change:foo&quot;, this.doStuff, this);
        // call the base type&apos;s method, since we are overriding it
        Backbone.View.prototype.remove.call(this);
    }
})
</code></pre><p>將 Backbone.js View Remove 改寫如下</p>
<pre><code>remove: function(){
    this.model.off(&quot;change:foo&quot;, this.doStuff, this);

    // call the base type&apos;s method, since we are overriding it
    Backbone.View.prototype.remove.call(this);
}
</code></pre><p>這樣就可以解決僵屍事件，但是如果有十個事件，那在 remove 裏面就會寫的很雜，所以在 0.9.9 版本出現 listenTo 和 stopListening 來解決此問題。程式碼改成如下</p>
<pre><code>Backbone.View.extend({
    initialize: function(){
        this.listenTo(this.model, &quot;change:foo&quot;, this.doStuff);
    },

    doStuff: function(foo){
        // do stuff in response to &quot;foo&quot; changing
    }

    // we don&apos;t need this. the default `remove` method calls `stopListening` for us
    // remove: function(){
        // this.stopListening();
        // ...
    //}
})
</code></pre><p>注意四大要點</p>
<ol>
<li><p>在 Backbone.View 裡面改用 listenTo 寫法</p>
</li>
<li><p>將 this.model 傳入 listenTo function</p>
</li>
<li><p>不用傳入最後一個參數 this 當作 context 變數</p>
</li>
<li><p>不需要再 override Backbone.View 的 remove function 了，因為在程式碼裏面就會自動呼叫 this.stopListening() 所以以後不要在寫 this.model.on 了，</p>
</li>
</ol>
<p>請全面改寫成 this.listenTo(this.model, ..) 寫法。</p>
<hr>
<p>事件模块Backbone.Events在Backbone中占有十分重要的位置，其他模块Model，Collection，View所有事件模块都依赖它。通过继承Events的方法来实现事件的管理，可以说，它是Backbone的核心组成部分。</p>
<p>此外，事件模块的所有方法都挂在了全局的Backbone上，如果你的代码中需要用到自定义事件(实现观察者模式)，可以直接使用它。</p>
<p>一、Events API</p>
<p>1.0之前只提供了三个基本方法 on/once/off/trigger，1.0开始增加了几个实用方法 listenTo/listenToOnce/stopListening。</p>
<p>以下是各个方法的意义</p>
<p>on 添加自定义事件<br>off 删除自定义事件<br>trigger 派发自定义事件<br>once 添加只执行一次的自定义事件 （内部依赖于_.once）<br>listenTo 添加一个观察对象<br>listenToOnce 添加一个仅执行一次的观察对象<br>stopListening 删除添加的观察对象</p>
<p>二、基本事件方法</p>
<p>1.绑定on方法</p>
<p>使用on方法可以给一个对象的自定义事件绑定触发该事件时执行的函数，当自定义的事件触发时，绑定的函数将会被执行。其调用格式如下：</p>
<p>obj.on(eventName, function, [context])</p>
<p>其中，参数Obj表示对象本身；eventName表示自定义事件的事件名；function表示当事件触发时被执行的函数；可选参数context表示上下文对象，用于对象级事件的监听，即当一个对象需要监听另一个对象的事件时，可以使用该参数。</p>
<p>使用on方法不仅可以绑定用户的自定义事件，可以直接监听对象自带的一些事件，下面通过一些简单示例来演示具体使用过程。</p>
<p>示例1：使用on方法监听默认事件</p>
<pre><code>var Person = Backbone.Model.extend({
  defaults : {
    name : &quot;&quot;,
    sex : &quot;&quot;
  }
});
var man = new Person();
man.on(&apos;change&apos;, function () {
  console.log(&apos;对象的默认值发生了变化&apos;);
});
man.set(&apos;name&apos;, &apos;breezefeng&apos;);
在上述代码中，首先定义一个名称为Person的数据模型类。在定义时，通过defaults参数设置两个名为“name” 和 “sex” 的默认数据项。然后，实例化一个名为man的模型类对象，并使用on方法向该对象绑定触发change事件时执行的函数，即只要对象的属性值发生变化，将会触发change事件。

示例2：使用on方法监听属性事件

var Person = Backbone.Model.extend({
  defaults : {
    name : &quot;&quot;,
    sex : &quot;女&quot;
  }
});
var man = new Person();
man.on(&apos;change&apos;, function () {
  console.log(&apos;对象的默认值发生了变化&apos;);
});
man.on(&apos;change:sex&apos;, function (model, value) {
  console.log(&apos;你修改了性别属性值，最新值是：&apos; + value)
});
man.set(&apos;sex&apos;, &apos;男&apos;);
</code></pre><p>在上述代码中，分别给man对象绑定了两个事件，一个是默认事件change，另一个是属性事件change:sex，即sex属性变化事件。在属性变化事件的回调函数中，通过回传的value参数获取最新修改后的属性值。</p>
<p>示例3：使用on方法获取属性修改前的值</p>
<p>在使用on方法绑定change和change属性事件时，还可以通过回调函数中的model对象获取属性修改前的所有值，如下所示：</p>
<pre><code>model.previous(&apos;attrName&apos;)  //用于获取对象中某个属性的原有值

model.previousAttributes()  //返回一个对象，保存上一个状态的所有属性的原有值

var Person = Backbone.Model.extend({
  defaults : {
    name : &quot;&quot;,
    sex : &quot;女&quot;,
    age : 32,
    score : 120
  }
});
var man = new Person();
man.on(&apos;change:score&apos;, function (model, value) {
  var oldScore = model.previous(&apos;score&apos;);
  if (value &gt; oldScore) {
    console.log(&apos;你比上次进步了&apos; + (value - oldScore) + &apos;分&apos;);
  } else if (value &lt; oldScore) {
    console.log(&apos;你比上次落后了&apos; + (oldScore - value) + &apos;分&apos;);
  } else {
    console.log(&apos;你的成绩没有变化&apos;);
  }
});
man.on(&apos;change:age&apos;, function (model, value) {
  var objAttr = model.previousAttributes();
  var oldAge = objAttr.age;
  if (value &gt; oldAge) {
    console.log(&apos;你又长大了&apos; + (value - oldAge) + &apos;岁&apos;);
  } else if (value &lt; oldAge) {
    console.log(&apos;你又年轻了&apos; + (oldAge - value) + &apos;岁&apos;);
  } else {
    console.log(&apos;你的年龄没有变化&apos;);
  }
});
man.set({
  age : &apos;36&apos;,
  score : 200
});
</code></pre><p>在上述代码中，通过使用on方法分别绑定对象man的change:score 和 change:age两个属性事件。</p>
<p>在第一个属性事件change:score 中，通过回调函数中model模型对象的previous方法，获取上一次保存的score属性值。</p>
<p>在第二个属性事件change:age 中，通过回调函数中model模型对象的previousAttributes方法，获取上一次保存结果的对象，并将对象保存至变量objAttr中，再通过访问对象变量objAttr的方式获取上一次保存的age属性值。</p>
<p>示例4：使用on方法绑定多个事件</p>
<p>在Backbone中，除了使用on方法绑定单个对象的事件，还可以使用该方法同时绑定多个对象的事件。绑定的格式有两种，第一种为各个事件使用空格隔开，格式如下：</p>
<pre><code>obj.on(&quot;eventName1 eventName2&quot;, function)
</code></pre><p>其中，使用空格隔开的参数eventName1 和 eventName2 表示被绑定的多个事件名称，function表示所有被绑定事件都要执行的自定义函数。</p>
<p>第一种绑定方式代码：</p>
<pre><code>var Person = Backbone.Model.extend({
  defaults : {
    name : &quot;&quot;,
    sex : &quot;女&quot;,
    age : 32,
    score : 120
  }
});
var man = new Person();
man.on(&apos;change:score change:age&apos;, function (model, value) {
  var oldAge = model.previous(&apos;age&apos;);
  var newAge = model.get(&apos;age&apos;);
  if (oldAge != newAge) {
    console.log(&apos;age原值:&apos; + oldAge + &apos;, 新值:&apos; + newAge);
  }

  var oldScore = model.previous(&apos;score&apos;);
  var newScore = model.get(&apos;score&apos;);
  if (oldScore != newScore) {
    console.log(&apos;score原值:&apos; + oldScore + &apos;, 新值:&apos; + newScore);
  }
});

man.set(&apos;age&apos;, 36);
man.set(&apos;score&apos;, 200);
</code></pre><p>在使用on方法绑定事件中，有两种格式可以绑定多个事件，除第一种使用空格之外，第二种方法为使用对象方式绑定多个事件，格式如下：</p>
<pre><code>var objEvent = {
    eventName1 : function1,
    eventName2 : function2
    ...
};
obj.on(objEvent);
</code></pre><p>在上述代码中，首先定义一个哈希对象objEvent，并以key/value的方式向该对象批量添加各个事件名称和要执行的事件函数，然后通过使用on方法绑定哈希对象即可。</p>
<p>接下来将第一种使用空格方式绑定多个事件的代码修改成使用哈希对象绑定多个事件功能，修改代码如下：</p>
<pre><code>var Person = Backbone.Model.extend({
  defaults : {
    name : &quot;&quot;,
    sex : &quot;女&quot;,
    age : 32,
    score : 120
  }
});
var man = new Person();
var objEvent = {
  &apos;change:score&apos; : score_change,
  &apos;change:age&apos; : age_change
};
man.on(objEvent);
function score_change (model, value) {
  var oldScore = model.previous(&apos;score&apos;);
  var newScore = model.get(&apos;score&apos;);
  if (oldScore != newScore) {
    console.log(&apos;score原值:&apos; + oldScore + &apos;, 新值:&apos; + newScore);
  }
}
function age_change (model, value) {
  var oldAge = model.previous(&apos;age&apos;);
  var newAge = model.get(&apos;age&apos;);
  if (oldAge != newAge) {
    console.log(&apos;age原值:&apos; + oldAge + &apos;, 新值:&apos; + newAge);
  }
}
man.set({
  age : 36,
  score : 200
});
</code></pre><p>2.绑定一次 once方法</p>
<p>在Backbone中，除使用on方法可以绑定对象的事件之外，还可以使用once完成对象事件的绑定，只不过once方法绑定的事件只执行一次，之后即使触发也不执行，其调用格式如下：</p>
<pre><code>obj.once(eventName, function, [context])
</code></pre><p>示例代码如下：</p>
<pre><code>var Person = Backbone.Model.extend({
  defaults : {
    name : &quot;&quot;,
    sex : &quot;女&quot;,
    age : 32,
    score : 120
  }
});
var man = new Person();
var intNum = 0;
man.once(&apos;change&apos;, function () {
  intNum++;
  console.log(&apos;事件触发的次数为 : &apos; + intNum);  //1
});
man.set(&apos;age&apos;, 36);
man.set(&apos;age&apos;, 37);
</code></pre><p>最终intNum打印出1，说明绑定的事件函数只执行了一次。</p>
<p>3.触发事件 trigger方法</p>
<p>trigger也是Backbone事件API中的一个重要方法，它的功能是触发对象的某一个事件，其调用格式如下：</p>
<pre><code>obj.trigger(eventName)
</code></pre><p>使用trigger方法可以手动触发对象的任何事件，不仅是系统自带的系统事件，还可以是自定义事件。示例代码如下：</p>
<pre><code>var Person = Backbone.Model.extend({
  defaults : {
    name : &quot;&quot;,
    sex : &quot;女&quot;,
    age : 32,
    score : 120
  }
});
var man = new Person();
man.on(&apos;change_age_sex&apos;, function () {
  console.log(&apos;你手动触发了一个自定义事件&apos;);
});
man.on(&apos;change:age&apos;, function (model, value) {
  if (value != undefined) {
    console.log(&apos;你修改后的年龄为 : &apos; + value);
  } else {
    console.log(&apos;你手动触发了一个年龄修改事件&apos;);
  }
});
man.trigger(&apos;change_age_sex&apos;);
man.trigger(&apos;change:age&apos;);
man.set(&apos;age&apos;, 36);
</code></pre><p>不难看出，trigger方法的功能就是手动执行对象绑定的事件，类似于自定义一个函数后，调用该事件名。因此，该方法就是执行事件，不论该事件是自定义的还是系统自带的。</p>
<p>4.移出事件 off方法</p>
<p>在Backbone中，与绑定事件的on方法相对的是移除事件的off方法，该方法的功能是移除对象中已绑定的某个、多个或全部的时间，其调用格式如下：</p>
<pre><code>obj.off(eventName, function, [context])
</code></pre><p>示例1：使用off方法移出对象的某个或多个绑定事件</p>
<p>在Backbone中，如果要移除对象的某个绑定事件，可以调用对象的off方法，指定需要移除的事件名称；如果有多个事件名称，则用空格隔开。</p>
<pre><code>var Person = Backbone.Model.extend({
  defaults : {
    name : &quot;&quot;,
    sex : &quot;女&quot;,
    age : 32,
    score : 120
  }
});
var man = new Person();
var m = 0, n = 0;
var callback_a = function () {
  m++;
  console.log(&apos;你执行事件的次数为：&apos; + m);
};
var callback_b = function () {
  n++;
  console.log(&apos;你执行事件的次数为：&apos; + n)
};
man.on(&apos;event_a&apos;, callback_a);
man.on(&apos;event_b&apos;, callback_b);
man.off(&apos;event_a&apos;);
man.trigger(&apos;event_a event_b&apos;);
man.off(&apos;event_a event_b&apos;);
man.trigger(&apos;event_a event_b&apos;);
</code></pre><p>示例2：使用off方法移除绑定事件的某个函数</p>
<p>在Backbone中，不仅可以调用对象的off方法移除已绑定的一个或多个事件，还可以移除绑定事件执行的某个函数。</p>
<pre><code>var Person = Backbone.Model.extend({
  defaults : {
    name : &quot;&quot;,
    sex : &quot;女&quot;,
    age : 32,
    score : 120
  }
});
var man = new Person();
var m = 0, n = 0;
var callback_a = function () {
  m++;
  console.log(&apos;你执行事件的次数为：&apos; + m);
};
var callback_b = function () {
  n++;
  console.log(&apos;你执行事件的次数为：&apos; + n)
};
man.on(&apos;event_a&apos;, callback_a);
man.on(&apos;event_b&apos;, callback_b);
man.off(&apos;event_a&apos;, callback_a);
man.trigger(&apos;event_a event_b&apos;);
man.off(&apos;event_b&apos;, callback_b);
man.trigger(&apos;event_a event_b&apos;);
</code></pre><p>示例3：使用off方法移除对象的全部绑定事件</p>
<p>在Backbone中，对象的off方法除了可以移除某个或多个事件、事件执行函数外，还可以通过不带参数的方式移除全部已绑定的事件，其调用格式如下：</p>
<pre><code>obj.off()

var Person = Backbone.Model.extend({
  defaults : {
    name : &quot;&quot;,
    sex : &quot;女&quot;,
    age : 32,
    score : 120
  }
});
var man = new Person();
var m = 0, n = 0;
var callback_a = function () {
  m++;
  console.log(&apos;你执行事件的次数为：&apos; + m);
};
var callback_b = function () {
  n++;
  console.log(&apos;你执行事件的次数为：&apos; + n)
};
man.on(&apos;event_a&apos;, callback_a);
man.on(&apos;event_b&apos;, callback_b);
man.off();
man.trigger(&apos;event_a event_b&apos;);
</code></pre><p>三、新增事件方法</p>
<p>1.监听事件 listenTo方法</p>
<p>相对于对象的on方法而言，listenTo方法的监听效果更为突出，它是一个对象监听另一个对象的事件，如果被监听对象触发了被监听的事件，执行相应的回调函数或代码块。例如，view对象要监听model对象的change事件，如果model对象触发了change事件，则需要刷新当前view对象，即执行下列监听方法的代码：</p>
<pre><code>view.listenTo(model, &apos;change&apos;, view.render)
</code></pre><p>上面监听方法也等价于如下代码：</p>
<pre><code>model.on(&apos;change&apos;, view.render, view)
</code></pre><p>其中，第三个参数为上下文环境对象，此时它的值为view，即model对象在触发change事件时，关联view对象进行执行view.render动作。</p>
<p>通过上述对listenTo方法的简单介绍，我们知道它是一个对象级别的事件监听方法，即在执行该方法时，必须要有两个对象，其调用格式如下：</p>
<p>obj1.listenTo(obj2, eventName, function</p>
<p>其中，参数obj1，obj2都为对象，参数eventName是obj2对象触发的事件名称，参数function为当obj2触发指定的eventName事件时，obj1所执行的自定义函数。</p>
<pre><code>var Person = Backbone.Model.extend({
  defaults : {
    name : &quot;&quot;,
    sex : &quot;女&quot;,
    age : 32,
    score : 120
  }
});
var man = new Person();
var obj = _.extend({}, Backbone.Events);
obj.listenTo(man, &apos;change:age&apos;, function (model, value) {
  var oldAge = model.previous(&apos;age&apos;);
  var newAge = model.get(&apos;age&apos;);
  if (oldAge != newAge) {
    console.log(&apos;age原值:&apos; + oldAge + &apos;, 新值:&apos; + newAge);
  }
});
man.set(&apos;age&apos;, 36);
</code></pre><p>2.监听一次 listenToOnce方法</p>
<p>在BackBone中listenTo方法 和 listenToOnce方法调用方式完全一致，唯一区别是前者是一个对象一直监听另一个对象事件的触发，而后者是仅监听一次。</p>
<pre><code>var Person = Backbone.Model.extend({
  defaults : {
    name : &quot;&quot;,
    sex : &quot;女&quot;,
    age : 32,
    score : 120
  }
});
var man = new Person();
var obj = _.extend({}, Backbone.Events);
var intNum = 0;
obj.listenToOnce(man, &apos;change:age&apos;, function (model, value) {
  intNum++;
  console.log(&apos;事件触发的次数为:&apos; + intNum);
});
man.set(&apos;age&apos;, 36);
man.set(&apos;age&apos;, 37);
</code></pre><p>3.停止监听 stopListening方法</p>
<p>在Backbone中，与单个对象的off方法相同，对象级别的事件监听也有停止方法，即stopListening方法，其调用格式如下：</p>
<pre><code>obj1.stopListening(obj2, eventName, function)

var Person = Backbone.Model.extend({
  defaults : {
    name : &quot;&quot;,
    sex : &quot;女&quot;,
    age : 32,
    score : 120
  }
});
var man = new Person();
var obj = _.extend({}, Backbone.Events);
obj.listenTo(man, &apos;change:name&apos;, function (model, value) {
  console.log(&apos;姓名修改后的值为:&apos; + value);
});
obj.listenTo(man, &apos;change:age&apos;, function (model, value) {
  console.log(&apos;年龄修改后的值为:&apos; + value);
});
obj.listenTo(man, &apos;change:score&apos;, function (model, value) {
  console.log(&apos;分数修改后的值为:&apos; + value);
});
//停止监听某一个事件
obj.stopListening(man, &apos;change:name&apos;);
man.set(&apos;name&apos;, &apos;张三&apos;);
man.set(&apos;age&apos;, 35);
man.set(&apos;score&apos;, 600);
//停止监听两个事件
obj.stopListening(man, &apos;change:name change:age&apos;);
man.set(&apos;name&apos;, &apos;李四&apos;);
man.set(&apos;age&apos;, 36);
man.set(&apos;score&apos;, 601);
//停止监听全部事件
obj.stopListening();
man.set(&apos;name&apos;, &apos;王五&apos;);
man.set(&apos;age&apos;, 37);
man.set(&apos;score&apos;, 602);
</code></pre><p>以上就是Backbone.Events模块所有API的使用，欢迎留言讨论~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-12-event-demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-12-event-demo/" itemprop="url">点击事件绑定Demo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-12-event-demo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-12-event-demo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="action1"> 这是一个 .action1 的类，我上面有一个点击事件:action1 </div><br><div class="act"> 这是一个 .act 的类，我上面有一个点击事件:act</div><br><div class="else do doing"> 这是一个 .do 和 .doing 的类，我上面有点击事件:do和doing</div>

<div class="myhide" style="display:none;">这是一个隐藏的div,我有一个样式：myhide,最后由下面按钮显示</div>

<p><a class="btn btn-primary">显示隐藏</a></p>
<div id="myid">这是一个没有事件的div</div>

<p>代码如下：</p>
<pre><code>var addEvent = {
  &quot;action1&quot;: function() {
    console.log(&apos;action1&apos;);
  },
  &quot;act&quot;:function() {
    console.log(&apos;act&apos;);
    alert(&apos;act&apos;);
  },
  &quot;do&quot;:function() {
    console.log(&apos;do&apos;);
  },
  &quot;doing&quot;:function() {
    console.log(&apos;doing&apos;);
  },
  &quot;btn-primary&quot;:function(){
    console.log(&quot;btn-primary&quot;);
    $(&apos;.myhide&apos;).show();
  },
  &quot;myhide&quot;:function(){
    console.log(&apos;我是隐藏后再显示的内容哦！&apos;);
  }
}

$(function(){
  $(&quot;body&quot;).on(&apos;click&apos;,&apos;[class]&apos;,function(e){
    for(var cn in addEvent){
      if($(this).hasClass(cn)) {
        addEvent[cn]();
      }
    }
    return false;
  })
})
</code></pre><script>
var addEvent = {
  "action1": function() {
    console.log('action1');
  },
  "act":function() {
    console.log('act');
    alert('act');
  },
  "do":function() {
    console.log('do');
  },
  "doing":function() {
    console.log('doing');
  },
  "btn-primary":function(){
    console.log("btn-primary");
    $('.myhide').show();
  },
  "myhide":function(){
    console.log('我是隐藏后再显示的内容哦！');
  }
}

$(function(){
  $("body").on('click','[class]',function(e){
    for(var cn in addEvent){
      if($(this).hasClass(cn)) {
        addEvent[cn]();
      }
    }
  })

})

</script>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-10-12-javascript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-10-12-javascript/" itemprop="url">JavaScript 代码性能优化总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-10-12-javascript/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-10-12-javascript/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="尽量使用源生方法"><a href="#尽量使用源生方法" class="headerlink" title="尽量使用源生方法"></a>尽量使用源生方法</h1><p>javaScript是解释性语言，相比编译性语言执行速度要慢。浏览器已经实现的方法，就不要再去实现一遍了。另外，浏览器已经实现的方法在算法方面已经做了很多优化。</p>
<p>避免全局查找</p>
<p>在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些。</p>
<pre><code>// bad
function search(){
    alert(window.location.host + window.location.href)
}

// good
function search(){
    var location = window.location;
    alert(location.host + location.href);
}
</code></pre><h1 id="尽量减少循环次数"><a href="#尽量减少循环次数" class="headerlink" title="尽量减少循环次数"></a>尽量减少循环次数</h1><p>少一层循环，就能提高数倍性能。如果要对一个数组的每个元素进行多次操作，尽可能使用一次循环，多次操作，而不是多次循环，每次循环执行一次操作。尤其是在进行多个正则匹配的时候，尽可能合并正则表达式，在一次遍历中尽可能找到相应的匹配。</p>
<p>循环</p>
<pre><code>// 通常循环的写法

var objs = [obj1,obj2,obj3],
    len  = objs.length;

for( var i = 0;i&lt;len;i++){
    dosth(objs[i]);
}

// 当循环遍历的对象是obj时，可以采用下面的方式

var objs =  [obj1,obj2,obj3],
    len  = objs.length,
    i = 0;

while(obj = objs[i++]) {
    dosth(obj);
}
</code></pre><p>switch</p>
<pre><code>// 通常的写法

function funa() {}
function funb() {}
function func() {}

switch(con) {
    case &apos;a&apos;:
        funa();
        break;
    case &apos;b&apos;:
        funb();
        break;
    case &apos;c&apos;:
        func();
        break;
}

// 换种写法
function funa() {}
function funb() {}
function func() {}

var funs = {
    &apos;a&apos;: funa,
    &apos;b&apos;: funb,
    &apos;c&apos;: func
}

funs[con]();

// Tip: 取值或者函数调用都可以用类似的方法来做
</code></pre><h1 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h1><p>将条件分支，按可能性顺序从高到低排列：可以减少解释器对条件的探测次数。</p>
<p>在同一条件 &gt;2条件分支时，使用switch优于if：switch分支选择的效率高于if，在IE下尤为明显。4条分支的测试，IE下switch的执行时间约为if的一半。</p>
<p>使用三目运算符替代条件分支。</p>
<pre><code>if(a &gt; b) {
    num = a;
} else {
    num = b;
}

// 使用三目运算符

num = a&gt;b ? a : b;
</code></pre><p>定时器</p>
<p>如果针对的是不断运行的代码，不应该使用setTimeout，而应该是用setInterval，因为setTimeout每一次都会初始化一个定时器，而setInterval只会在开始的时候初始化一个定时器。</p>
<pre><code>var timeoutTimes = 0;
function timeout() {
    timeoutTimes++;
    if(timeoutTimes &lt; 10) {
        setTimeout(timeout,10);
    }
}
timeout();

// 可以替换为

var intervalTimes = 0;
function interval() {
    intervalTimes++；
    if(intervalTimes &gt;= 10){
        clearInterval(interv);
    }
}
var interv = setInterval(interval,10);
</code></pre><p>创建对象的另外一个办法-不使用new</p>
<pre><code>// 我们要连续创建一些简单的object对象，并且拥有默认的属性，会这样写：
function jason() {
    this.propa = &apos;&apos;;
    this.porpb = [];
    this.propc = 0;
}
var objs = [],
    i    = 0,
    obj;
while(i&lt;100) {
    obj = new jason();
    obj.propc = i;
    objs.push(obj);
}

// 换种写法
function jason() {
    return {
        propa : &apos;&apos;,
        porpb : [],
        propc : 0;
    }

}
var objs = [],
    i    = 0,
    obj;
while(i&lt;100) {
    obj = jason();
    obj.propc = i;
    objs.push(obj);
}
// tips: 直接声明的方式，复用性能会差一些。
</code></pre><h1 id="用做标记的变量尽可能使用布尔类型"><a href="#用做标记的变量尽可能使用布尔类型" class="headerlink" title="用做标记的变量尽可能使用布尔类型"></a>用做标记的变量尽可能使用布尔类型</h1><p>直接用true和false做标记，不要使用数字或者字符串的1和0来做标记。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="飞来小侠" />
          <p class="site-author-name" itemprop="name">飞来小侠</p>
           
              <p class="site-description motion-element" itemprop="description">依法不依人，依义不依语。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">58</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/flyingliu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/5872146656" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/guolaiwan/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      豆瓣
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/liu-fei-lai/activities" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">飞来小侠</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Pisces
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://ananfo.disqus.com/count.js" async></script>
    

    

  




	





  










  





  

  

  

  

  

  

</body>
</html>
