<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="依法不依人，依义不依语。">
<meta property="og:type" content="website">
<meta property="og:title" content="如是我闻">
<meta property="og:url" content="http://flyingliu.github.io/page/4/index.html">
<meta property="og:site_name" content="如是我闻">
<meta property="og:description" content="依法不依人，依义不依语。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="如是我闻">
<meta name="twitter:description" content="依法不依人，依义不依语。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://flyingliu.github.io/page/4/"/>





  <title>如是我闻</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">如是我闻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">色即是空，空即是色</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-10-20-js-yunsuanfu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-10-20-js-yunsuanfu/" itemprop="url">js中运算符的优先级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-10-20-js-yunsuanfu/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-10-20-js-yunsuanfu/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JScript 中的运算符优先级是一套规则。该规则在计算表达式时控制运算符执行的顺序。具有较高优先级的运算符先于较低优先级的运算符执行。例如，乘法的执行先于加法。</p>
<p>下表按从最高到最低的优先级列出 JScript 运算符。具有相同优先级的运算符按从左至右的顺序求值。</p>
<p>|运算符|    描述|<br>|. <a href=""></a>|    字段访问、数组下标、函数调用以及表达式分组|<br>|++ – - ~ ! delete new typeof void    |一元运算符、返回数据类型、对象创建、未定义值|<br>|* / %    |乘法、除法、取模|<br>|+ - +    |加法、减法、字符串连接|<br>|&lt;&lt; &gt;&gt; &gt;&gt;&gt;    |移位|<br>|&lt; &lt;= &gt; &gt;= instanceof|    小于、小于等于、大于、大于等于、instanceof|<br>|== != === !==    |等于、不等于、严格相等、非严格相等|<br>|&amp;    |按位与|<br>|^    |按位异或|<br>||    |按位或|<br>|&amp;&amp;|    逻辑与|<br>||| |    逻辑或|<br>|?:|    条件|<br>|= oP=    |赋值、运算赋值|<br>|,    |多重求值|</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-11-05-js-this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-11-05-js-this/" itemprop="url">再次理解js中的this</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-11-05-js-this/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-11-05-js-this/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JavaScript 是一种脚本语言，支持函数式编程、闭包、基于原型的继承等高级功能。JavaScript一开始看起来感觉会很容易入门，但是随着使用的深入，你会发现JavaScript其实很难掌握，有些基本概念让人匪夷所思。其中JavaScript 中的 this 关键字，就是一个比较容易混乱的概念，在不同的场景下，this会化身不同的对象。有一种观点认为，只有正确掌握了 JavaScript 中的 this 关键字，才算是迈入了 JavaScript 这门语言的门槛。在主流的面向对象的语言中（例如Java,C#等)，this 含义是明确且具体的，即指向当前对象。一般在编译期绑定。而 JavaScript 中this 在运行期进行绑定的，这是JavaScript 中this 关键字具备多重含义的本质原因。</p>
<p>JavaScript由于其在运行期进行绑定的特性，JavaScript 中的 this 可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。JavaScript 中函数的调用有以下几种方式：作为对象方法调用，作为函数调用，作为构造函数调用，和使用 apply 或 call 调用。常言道，字不如表，表不如图。为了让人更好的理解JavaScript this 到底指向什么？下面用一张图来进行解释：</p>
<p><img src="/src/images/this1.jpg" alt=""></p>
<p>上图我称之为”JavaScript this决策树”（非严格模式下）。下面通过例子来说明这个图如何来帮助我们对this进行判断：</p>
<pre><code>var point = { 
x : 0, 
y : 0, 
moveTo : function(x, y) { 
     this.x = this.x + x; 
     this.y = this.y + y;
 console.log(this)
     } 
};

//决策树解释：point.moveTo(1,1)函数不是new进行调用，进入否决策，
//是用dot(.)进行调用，则指向.moveTo之前的调用对象，即point
point.moveTo(1,1); //this 绑定到当前对象,即point对象
</code></pre><p>point.moveTo（）函数在 “JavaScript this决策树”中进行判定的过程是这样的：</p>
<p>1）point.moveTo函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；</p>
<p>2）point.moveTo函数是用dot(.)进行调用的，即进入“是”分支，即这里的this指向point.moveTo中.之前的对象point;</p>
<p>图解point.moveTo函数的this指向什么的解析图如下图所示：</p>
<p><img src="/src/images/this2.jpg" alt=""></p>
<p>再举例，看下面的代码：</p>
<pre><code>function func(x) { 
 this.x = x; 
 } 
func(5); //this是全局对象window，x为全局变量
//决策树解析：func()函数是用new进行调用的么？为否，进入func()函数是用dot进行调用的么？为否，则 this指向全局对象window
x;//x =&gt; 5
</code></pre><p>func（）函数在 “JavaScript this决策树”中进行判定的过程是这样的：</p>
<p>1）func(5)函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；</p>
<p>2）func(5)函数不是用dot(.)进行调用的，即进入“否”分支，即这里的this指向全局变量window，那么this.x实际上就是window.x;</p>
<p>图解func函数的this指向什么的解析图如下图所示：</p>
<p><img src="/src/images/this3.jpg" alt=""></p>
<p>针对作为函数直接调用的方式，下面看一个复杂的例子：</p>
<pre><code>var point = { 
 x : 0, 
 y : 0, 
 moveTo : function(x, y) { 
     // 内部函数
     var moveX = function(x) { 
     this.x = x;//this 指向什么？window
    }; 
    // 内部函数
    var moveY = function(y) { 
    this.y = y;//this 指向什么？window
    }; 
    moveX(x); 
    moveY(y); 
    } 
 }; 
 point.moveTo(1,1); 
 point.x; //=&gt;0 
 point.y; //=&gt;0 
 x; //=&gt;1 
 y; //=&gt;1
</code></pre><p>point.moveTo(1,1)函数实际内部调用的是moveX()和moveY()函数, moveX()函数内部的this在 “JavaScript this决策树”中进行判定的过程是这样的：</p>
<p>1）moveX(1)函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；</p>
<p>2）moveX(1)函数不是用dot(.)进行调用的，即进入“否”分支，即这里的this指向全局变量window，那么this.x实际上就是window.x;</p>
<p>下面看一下作为构造函数调用的例子：</p>
<pre><code>function Point(x,y){ 
    this.x = x; // this ?
    this.y = y; // this ?
 }
var np=new Point(1,1);
np.x;//1
var p=Point(2,2);
p.x;//error, p是一个空对象undefined
window.x;//2
</code></pre><p>Point(1,1)函数在var np=new Point(1,1)中的this在 “JavaScript this决策树”中进行判定的过程是这样的：</p>
<p>1）var np=new Point(1,1)调用是用new进行调用的么？这个明显是，进入“是”分支，即this指向np；</p>
<p>2）那么this.x=1，即np.x=1；</p>
<p>Point(2,2)函数在var p= Point(2,2)中的this在 “JavaScript this决策树”中进行判定的过程是这样的：</p>
<p>1）var p= Point(2,2)调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；</p>
<p>2）Point(2,2)函数不是用dot(.)进行调用的？判定为否，即进入“否”分支，即这里的this指向全局变量window，那么this.x实际上就是window.x;</p>
<p>3）this.x=2即window.x=2.</p>
<p>最后看一下函数用call 和apply进行调用的例子：</p>
<pre><code>function Point(x, y){ 
    this.x = x; 
    this.y = y; 
    this.moveTo = function(x, y){ 
        this.x = x; 
        this.y = y; 
    } 
 } 

var p1 = new Point(0, 0); 
var p2 = {x: 0, y: 0}; 
p1.moveTo.apply(p2, [10, 10]);//apply实际上为p2.moveTo(10,10)
p2.x//10
</code></pre><p>p1.moveTo.apply(p2,[10,10])函数在 “JavaScript this决策树”中进行判定的过程是这样的：</p>
<p>我们知道，apply 和 call 这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。p1.moveTo.apply(p2,[10,10])实际上是p2.moveTo(10,10)。那么p2.moveTo(10,10)可解释为：</p>
<p>1）p2.moveTo(10,10)函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；</p>
<p>2）p2.moveTo(10,10)函数是用dot(.)进行调用的，即进入“是”分支，即这里的this指向p2.moveTo(10,10)中.之前的对象p2,所以p2.x=10;</p>
<p>关于JavaScript函数执行环境的过程，IBM developerworks文档库中的一段描述感觉很不错，摘抄如下：</p>
<blockquote>
<p>   “JavaScript 中的函数既可以被当作普通函数执行，也可以作为对象的方法执行，这是导致 this 含义如此丰富的主要原因。一个函数被执行时，会创建一个执行环境（ExecutionContext），函数的所有的行为均发生在此执行环境中，构建该执行环境时，JavaScript 首先会创建 arguments变量，其中包含调用函数时传入的参数。接下来创建作用域链。然后初始化变量，首先初始化函数的形参表，值为 arguments变量中对应的值，如果 arguments变量中没有对应值，则该形参初始化为 undefined。如果该函数中含有内部函数，则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 undefined，其赋值操作在执行环境（ExecutionContext）创建成功后，函数执行时才会执行，这点对于我们理解 JavaScript 中的变量作用域非常重要，鉴于篇幅，我们先不在这里讨论这个话题。最后为 this变量赋值，如前所述，会根据函数调用方式的不同，赋给 this全局对象，当前对象等。至此函数的执行环境（ExecutionContext）创建成功，函数开始逐行执行，所需变量均从之前构建好的执行环境（ExecutionContext）中读取。”</p>
</blockquote>
<p>理解这段话对于理解Javascript函数将大有好处。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-11-13-foreach/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-11-13-foreach/" itemprop="url">理解JavaScript里的 [].forEach.call() 写法.</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-11-13-foreach/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-11-13-foreach/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用JavaScript的forEach方法，我们可以轻松的循环一个数组，但如果你认为<code>document.querySelectorAll()</code>方法返回的应该是个数组，而使用<code>forEach</code>循环它：</p>
<pre><code>/* Will Not Work */
document.querySelectorAll(&apos;.module&apos;).forEach(function() {
  // do something
});
</code></pre><p>执行上面的代码，你将会得到执行错误的异常信息。这是因为，<code>document.querySelectorAll()</code>返回的不是一个数组，而是一个<code>NodeList</code>。</p>
<p>对于一个NodeList，我们可以用下面的技巧来循环遍历它：</p>
<pre><code>var divs = document.querySelectorAll(&apos;div&apos;);

[].forEach.call(divs, function(div) {
  // do whatever
  div.style.color = &quot;red&quot;;
});
</code></pre><p>当然，我们也可以用最传统的方法遍历它：</p>
<pre><code>var divs = document.querySelectorAll(&apos;div&apos;), i;

for (i = 0; i &lt; divs.length; ++i) {
  divs[i].style.color = &quot;green&quot;;
}
</code></pre><p>还有一种更好的方法，就是自己写一个：</p>
<pre><code>// forEach method, could be shipped as part of an Object Literal/Module
var forEach = function (array, callback, scope) {
  for (var i = 0; i &lt; array.length; i++) {
    callback.call(scope, i, array[i]); // passes back stuff we need
  }
};

// 用法:
// optionally change the scope as final parameter too, like ECMA5
var myNodeList = document.querySelectorAll(&apos;li&apos;);
forEach(myNodeList, function (index, value) {
  console.log(index, value); // passes index + value back!
});
</code></pre><p>还有一种语法：for..of 循环，但似乎只有Firefox支持：</p>
<pre><code>/* Be warned, this only works in Firefox */

var divs = document.querySelectorAll(&apos;div );

for (var div of divs) {
  div.style.color = &quot;blue&quot;;
}
</code></pre><p>最后是一种不推荐的方法：给NodeList扩展一个forEach方法：</p>
<pre><code>NodeList.prototype.forEach = Array.prototype.forEach;

var divs = document.querySelectorAll(&apos;div&apos;).forEach(function(el) {
  el.style.color = &quot;orange&quot;;
})
</code></pre><p>循环 <code>NodeList</code> ，因为 <code>document.querySelectorAll()</code> 返回的并不是我们想当然的数组，而是 <code>NodeList</code>，对 <code>NodeList</code> ，它里面没有 <code>.forEach</code>方法，我们使用了这样的方法进行循环：</p>
<pre><code>var divs = document.querySelectorAll(&apos;div&apos;);

[].forEach.call(divs, function(div) {
  // do whatever
  div.style.color = &quot;red&quot;;
});
</code></pre><p>初次看到 <code>[].forEach.call()</code>这样的代码，我觉得这种写法很有趣，为什么要这样写？为什么要用空数值引申出的方法？于是研究了一下。</p>
<p><code>[]</code>就是个数组，而且是用不到的空数组。用来就是为了访问它的数组相关方法，比如<code>.forEach</code>。这是一种简写，完整的写法应该是这样：</p>
<p><code>Array.prototype.forEach.call(...);</code>很显然，简写更方便。</p>
<p>至于 <code>forEach</code> 方法，它可以接受一个函数参数：</p>
<pre><code>[1,2,3].forEach(function (num) { console.log(num); });
</code></pre><p>上面的这句代码中，我们可以访问 <code>this</code> 对象，也就是<code>[1,2,3]</code>，可以看出，这个 <code>this</code> 是个数组。</p>
<p>最后， <code>.call</code> 是一个<code>prototype</code>，JavaScript函数内置的。 <code>.call</code>使用它的第一个参数替换掉上面说的这个 <code>this</code> ，也就是你要传人的数组，其它的参数就跟 <code>forEach</code> 方法的参数一样了。</p>
<pre><code>[1, 2, 3].forEach.call([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], function (item, i, arr) {
    console.log(i + &quot;: &quot; + item);
});
// 0: &quot;a&quot;
// 1: &quot;b&quot;
// 2: &quot;c&quot;
</code></pre><p>因此， <code>[].forEach.call()</code> 是一种快速的方法访问 <code>forEach</code> ，并将空数组的 <code>this</code> 换成想要遍历的list。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-13-gitbook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-13-gitbook/" itemprop="url">Gitbook笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-13-gitbook/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-13-gitbook/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近准备写一本书，所以研究研究 GitBook ，本文对学习做个记录，主要目就是以后日常使用，就不用去翻看别的资料了。</p>
<p><em>什么是GitBook</em></p>
<p>GitBook 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书。</p>
<p>GitBook项目官网：<a href="http://www.gitbook.io" target="_blank" rel="external">http://www.gitbook.io</a><br>GitBook Github地址：<a href="https://github.com/GitbookIO/gitbook" target="_blank" rel="external">https://github.com/GitbookIO/gitbook</a><br>GitBook需要使用markdown格式编写，如果你不了解可以看看 这里 。</p>
<p>安装</p>
<p>需要先安装 Node ，安装步骤网上教程非常多，在此不详细介绍，安装好node后就可以使用npm安装GitBook了。</p>
<pre><code>gitbook-cli
</code></pre><p>需要先安装gitbook-cli，这个工具是用来管理gitbook工具的，这有点类似容器的意思，通过gitbook-cli可以在本地安装多个gitbook工具的不同版本。</p>
<p>使用如下命令安装GitBook。</p>
<pre><code>$ npm install gitbook-cli -g
</code></pre><p>安装完之后，你可以检验下是否安装成功。</p>
<pre><code>$ gitbook -V
</code></pre><p>安装gitbook</p>
<p>安装完gitbook-cli后，要使用gitbook还需要安装gitbook工具，可以通过如下命令安装。</p>
<pre><code>$ gitbook versions:install
</code></pre><p>安装好后可以通过如下命令查看是否安装成功。</p>
<pre><code>$ gitbook versions
</code></pre><p>都安装好后接下来我们就可以做点有意思的事情了。</p>
<p>常用命令</p>
<p>再开始做有意思的事情之前，先来熟悉下常用命令。</p>
<p>gitbook-cli常用命令</p>
<pre><code>gitbook -h # 查看帮助信息

gitbook versions # 查看本地安装的gitbook版本

gitbook versions:install # 安装最新版gitbook
gitbook versions:install 2.3.3 # 安装指定版本

gitbook versions:uninstall # 卸载当前选中版本
gitbook versions:uninstall 2.3.3 # 卸载指定版本

gitbook versions:link # 指定当前文件夹使用当前选中版本
gitbook versions:link 2.3.3 # 指定当前文件夹使用指定版本
gitbook versions:link path # 指定path使用指定版本

gitbook -v 2.3.3 # 指定当前使用哪个版本的gitbook
gitbook --gitbook 2.3.3 # 同上
</code></pre><p>gitbook常用命令</p>
<pre><code>$ gitbook init # 初始化一个仓库

$ gitbook install # 安装插件

$ gitbook serve ./图书名称 # 本地预览
$ gitbook serve --port 8001 # 指定端口

$ gitbook build ./repository --output=./outputFolder # 输出一个静态网站

$ gitbook help # 查看帮助
</code></pre><p>顺便吐槽一下gitbook命令设计是有问题，两个不同的命令耦合在了一起。</p>
<p>图书项目结构</p>
<p>README.md和SUMMARY.md是Gitbook项目必备的两个文件，也就是一本最简单的GitBook也必须含有这两个文件，它们在一本Gitbook中具有不同的用处。</p>
<p>README.md</p>
<p>这个文件相当于一本Gitbook的简介。自从GitBook 2.0.0开始支持自定义简介文件，在book.json中定义，这样README.md就可以用作项目的简介。</p>
<pre><code>{
  &quot;structure&quot;: {
      &quot;readme&quot;: &quot;myIntro.md&quot;
  }
}
</code></pre><p>更多信息请看 这里 。</p>
<p>SUMMARY.md</p>
<p>这个文件是一本书的目录结构，使用Markdown语法，一个简单的例子如下所示。</p>
<pre><code># Summary

* [Part I](part1/README.md)
    * [Writing is nice](part1/writing.md)
    * [GitBook is nice](part1/gitbook.md)
* [Part II](part2/README.md)
    * [We love feedback](part2/feedback_please.md)
    * [Better tools for authors](part2/better_tools.md)
</code></pre><p>更多信息请看 这里 。</p>
<p>发布</p>
<p>发布到GitHub 源代码保存到master分支，build出来的上传到gh-pages分支，就这么简单的搞定了。如果你还不会使用git和github，那么不妨读读我的另一篇文章《我的git笔记》。</p>
<p>发布到GitBook</p>
<p>还没想好，想好了再写。</p>
<p>总结</p>
<p>关于 GitBook 的更多资料可查看官网的 帮助文档 ，哪里的介绍比较全面，也会保持时时更新。</p>
<p>参考资料</p>
<p><a href="http://gitbook-zh.wanqingwong.com/" target="_blank" rel="external">Gitbook 使用入门</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-15-jekyll-on-heroku/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-15-jekyll-on-heroku/" itemprop="url">在heroku上建立jekyll静态网站</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-15-jekyll-on-heroku/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-15-jekyll-on-heroku/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.heroku.com" target="_blank" rel="external">heroku</a> 是一个非常受欢迎的站点托管服务商，而且提供比较稳定的免费服务。jekyll是一个使用广泛的静态站点管理工具，且github上的静态页面就是用的jekyll来发布的。其实直接在github上建静态站点也是一个不错的主意，现实情况是github经常被墙。这是一个灰常的国度！</p>
<p>好了，说说正事。我也是看到国外的<a href="http://www.jamesward.com/2014/09/24/jekyll-on-heroku" target="_blank" rel="external">一篇文章</a>,自己照着做居然真的做成了。</p>
<p><a href="http://yuge.herokuapp.com/" target="_blank" rel="external">狠狠点击这里查看</a></p>
<p>为了怕以后忘记，备份一下。</p>
<ol>
<li><p>在jekyll项目根目录下建立Gemfile文件</p>
<pre><code>source &apos;https://rubygems.org&apos;
ruby &apos;2.1.2&apos;
gem &apos;jekyll&apos;
gem &apos;kramdown&apos;
gem &apos;rack-jekyll&apos;
gem &apos;rake&apos;
gem &apos;puma&apos;
</code></pre></li>
<li><p>运行：bundler install</p>
</li>
<li><p>用Puma在服务器上启动站点，必须新建Procfile文件</p>
<p> web: bundle exec puma -t 8:32 -w 3 -p $PORT</p>
</li>
<li><p>新建Rakefile文件，ruby看不懂。</p>
<pre><code>namespace :assets do
  task :precompile do
    puts `bundle exec jekyll build`
  end
end
</code></pre></li>
<li><p>新建_config.yml 文件</p>
<pre><code># Build settings
markdown: kramdown
permalink: pretty
gems: [&apos;kramdown&apos;]
exclude: [&apos;config.ru&apos;, &apos;Gemfile&apos;, &apos;Gemfile.lock&apos;, &apos;vendor&apos;, &apos;Procfile&apos;, &apos;Rakefile&apos;]
</code></pre></li>
<li><p>新建config.ru 文件</p>
<pre><code>require &apos;rack/jekyll&apos;
require &apos;yaml&apos;
run Rack::Jekyll.new
</code></pre></li>
</ol>
<p>大功告成，然后把站点push到heroku上就可以进行发布了。如果你是空白站点或者只是试试看效果，可以直接down<a href="https://github.com/jamesward/jekyll-heroku" target="_blank" rel="external">作者的代码</a>下来。</p>
<p>代码下下来你可以直接在本地运行。</p>
<pre><code>jekyll serve --watch
</code></pre><p>注：我本地运行有报错，发现是没有装python。主要是Pygments的安装依赖Python。安装好运行</p>
<pre><code>gem install pygments.rb --version &quot;=0.5.0&quot;
</code></pre><p>OK，本地也可以正常预览了。</p>
<blockquote>
<p>warning: cannot close fd before spawn ‘which’ 不是内部或外部命令，也不是可运行的程序或批处理文件。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-14-backbone-jiaocheng/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-14-backbone-jiaocheng/" itemprop="url">Backbone.js 简易入门教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-14-backbone-jiaocheng/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-14-backbone-jiaocheng/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>因为最近的工作中使用到了backbone.js框架，所以在网上找了些资料，但是关于这个框架的中文资料实在是太少了，没有办法，只好自己翻译了壹篇简单的入门教材。如果翻译得不好，请大家口下留情。另外，大家也可以签出 <a href="http://agilityjs.com/" target="_blank" rel="external">Agility.js</a> 的代码，它也是壹个用于替代Backbone.js的壹个简单框架。</p>
<p>这是壹个简单的 Backbone.js 教程，由不言自明的”Hello World”到日益复杂的例子组成，它的出现是为了提供壹个平滑的从零过渡到流行的 Todos样例。<br>Backbone.js提供了壹个简化的用于组织你的Javascript应用的MVC框架。目的是为了得到更加容易维护的代码，通过解开那些富客户端应用中类似“意大利面条”式，在DOM的不同部分和后端服务器中的回调绑定。<br>教程开始于最小化的视图(View)对象，并且逐步的介绍事件绑定、事件处理、模型与集合。壹旦进入教程，可以使用右上角的导航菜单来查看其它例子。例子的序号按照其复杂程度递增。</p>
<p>下面的代码是基于HTML5的页面，最好使用最新版本的Firefox/Chrome/Opera/Safari浏览，不要用IE浏览器，你懂的。</p>
<pre><code>&lt;!DOCTYPE html&gt;
 &lt;html&gt;
 &lt;head&gt;
   &lt;meta charset=&quot;utf-8&quot;&gt;
   &lt;title&gt;hello-backbonejs&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
   &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;http://ajax.cdnjs.com/ajax/libs/json2/20110223/json2.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;http://ajax.cdnjs.com/ajax/libs/underscore.js/1.1.6/underscore-min.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;http://ajax.cdnjs.com/ajax/libs/backbone.js/0.3.3/backbone-min.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;...number.js...&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
 &lt;/body&gt;
 &lt;/html&gt;
</code></pre><h1 id="1-js-本例说明最小化的视图的声明与实例化。效果演示看这里。"><a href="#1-js-本例说明最小化的视图的声明与实例化。效果演示看这里。" class="headerlink" title="1.js  本例说明最小化的视图的声明与实例化。效果演示看这里。"></a>1.js  本例说明最小化的视图的声明与实例化。效果演示看<a href="/src/demos/hello.html">这里</a>。</h1><p>ListView类：是我们的主要的应用视图。</p>
<p>initialize()：自动调用上述实例，你可以在这里做除了界面元素事件以外的所有类型的绑定，比如说单击事件等等。</p>
<p>render()：用于渲染整个视图的函数。this.el：需要用户手动调用。</p>
<p>listView实例：实例化整个视图。</p>
<pre><code>(function($){
//自运行的闭包
  var ListView = Backbone.View.extend({
    el: $(&apos;body&apos;), // attaches `this.el` to an existing element.
    initialize: function(){
      _.bindAll(this, &apos;render&apos;); // fixes loss of context for &apos;this&apos; within methods
       this.render(); // not all views are self-rendering. This one is.
    },
    render: function(){
      $(this.el).append(&quot;&lt;ul&gt; &lt;li&gt;hello world&lt;/li&gt; &lt;/ul&gt;&quot;);
    }
  });
  var listView = new ListView();
})(jQuery);
</code></pre><h1 id="2-js-本例说明如何绑定DOM事件到视图的方法中。效果演示看这里。"><a href="#2-js-本例说明如何绑定DOM事件到视图的方法中。效果演示看这里。" class="headerlink" title="2.js  本例说明如何绑定DOM事件到视图的方法中。效果演示看这里。"></a>2.js  本例说明如何绑定DOM事件到视图的方法中。效果演示看<a href="/src/demos/hello2.html">这里</a>。</h1><p>events：DOM事件绑定到视图方法中，Backbone没有独立的控制器来处理这种绑定，它们全部发生在视图层中。</p>
<p>render()：正在展示如何将壹个按钮来添加到新的list条目中。</p>
<p>addItem()：通过上述点击事件自动触发的自定义的函数。</p>
<pre><code>(function($){
  var ListView = Backbone.View.extend({
    el: $(&apos;#mydiv&apos;), // el attaches to existing element
    events: {
      &apos;click button#add&apos;: &apos;addItem&apos;
    },
    initialize: function(){
      _.bindAll(this, &apos;render&apos;, &apos;addItem&apos;); // every function that uses &apos;this&apos; as the current object should be in here
      this.counter = 0; // total number of items added thus far
      this.render();
    },
    render: function(){
      $(this.el).append(&quot;&lt;button id=&apos;add&apos;&gt;Add list item&lt;/button&gt;&quot;);
      $(this.el).append(&quot;&lt;ul&gt;&lt;/ul&gt;&quot;);
    },
    addItem: function(){
      this.counter++;
      $(&apos;ul&apos;, this.el).append(&quot;&lt;li&gt;hello world&quot;+this.counter+&quot;&lt;/li&gt;&quot;);
    }
  });
  var listView = new ListView();
})(jQuery);
</code></pre><h1 id="3-js-这个样例说明如何使用模型中的集合来存储数据，以及如何将数据的改变绑定到视图。演示效果看这里。"><a href="#3-js-这个样例说明如何使用模型中的集合来存储数据，以及如何将数据的改变绑定到视图。演示效果看这里。" class="headerlink" title="3.js  这个样例说明如何使用模型中的集合来存储数据，以及如何将数据的改变绑定到视图。演示效果看这里。"></a>3.js  这个样例说明如何使用模型中的集合来存储数据，以及如何将数据的改变绑定到视图。演示效果看<a href="/src/demos/hello3.html">这里</a>。</h1><p>Item 类：模型层的原子（最小）部分。壹个模型是壹个基本的Javascript对象，例如：键值对，以及壹些用于事件响应、数据持久化的帮助函数等。</p>
<p>List 类：壹个条目的集合。基本上是壹些模型对象的数组和壹些帮助函数。</p>
<p>initialize() 正在实例化壹个集合，并且绑定它的添加事件到自己的方法 appendItem。（Backbone不在壹个单独的控制器中提供回调函数用于绑定）。</p>
<p>Save 参考这个以便它能够访问下面的callback范围内的数据。</p>
<p>addItem() 现在独立处理模型与视图。现在视图更新被授予下面的事件监听器 appendItem()。</p>
<p>appendItem() 被集合事件add触发，可视化的处理更新。</p>
<pre><code>(function($){

  var Item = Backbone.Model.extend({
    defaults: {
      part1: &apos;hello&apos;,
      part2: &apos;world&apos;
    }
  });

  var List = Backbone.Collection.extend({
    model: Item
  });

  var ListView = Backbone.View.extend({
    el: $(&apos;body&apos;),
    events: {
      &apos;click button#add&apos;: &apos;addItem&apos;
    },

    initialize: function(){
      _.bindAll(this, &apos;render&apos;, &apos;addItem&apos;, &apos;appendItem&apos;); // remember: every function that uses &apos;this&apos; as the current object should be in here

      this.collection = new List();
      this.collection.bind(&apos;add&apos;, this.appendItem); // collection event binder

      this.counter = 0;
      this.render();
    },
    render: function(){

      var self = this;
      $(this.el).append(&quot;&lt;button id=&apos;add&apos;&gt;Add list item&lt;/button&gt;&quot;);
      $(this.el).append(&quot;&lt;ul&gt;&lt;/ul&gt;&quot;);
      _(this.collection.models).each(function(item){ // in case collection is not empty
        self.appendItem(item);
      }, this);
    },

    addItem: function(){
      this.counter++;
      var item = new Item();
      item.set({
        part2: item.get(&apos;part2&apos;) + this.counter // modify item defaults
      });
      this.collection.add(item); // add item to collection; view is updated via event &apos;add&apos;
    },

    appendItem: function(item){
      $(&apos;ul&apos;, this.el).append(&quot;&lt;li&gt;&quot;+item.get(&apos;part1&apos;)+&quot; &quot;+item.get(&apos;part2&apos;)+&quot;&lt;/li&gt;&quot;);
    }
  });

  var listView = new ListView();
})(jQuery);
</code></pre><h1 id="4-js-这个样例说明如何渲染模型到专门查看的视图。演示效果看这里。"><a href="#4-js-这个样例说明如何渲染模型到专门查看的视图。演示效果看这里。" class="headerlink" title="4.js  这个样例说明如何渲染模型到专门查看的视图。演示效果看这里。"></a>4.js  这个样例说明如何渲染模型到专门查看的视图。演示效果看<a href="/src/demos/hello4.html">这里</a>。</h1><p>ItemView 类：负责渲染每个独立的条目。</p>
<p>appendItem() 不再负责渲染独立的项目。它现在授予 render() 方法到每个独立的 ItemView 实例。</p>
<pre><code>(function($){
  var Item = Backbone.Model.extend({
    defaults: {
      part1: &apos;hello&apos;,
      part2: &apos;world&apos;
    }
  });

  var List = Backbone.Collection.extend({
    model: Item
  });

  var ItemView = Backbone.View.extend({
    tagName: &apos;li&apos;, // name of (orphan) root tag in this.el
    initialize: function(){
      _.bindAll(this, &apos;render&apos;); // every function that uses &apos;this&apos; as the current object should be in here
    },
    render: function(){
      $(this.el).html(&apos;&lt;span&gt;&apos;+this.model.get(&apos;part1&apos;)+&apos; &apos;+this.model.get(&apos;part2&apos;)+&apos;&lt;/span&gt;&apos;);
      return this; // for chainable calls, like .render().el
    }
  });

  var ListView = Backbone.View.extend({
    el: $(&apos;body&apos;), // el attaches to existing element
    events: {
      &apos;click button#add&apos;: &apos;addItem&apos;
    },
    initialize: function(){
      _.bindAll(this, &apos;render&apos;, &apos;addItem&apos;, &apos;appendItem&apos;); // every function that uses &apos;this&apos; as the current object
      this.collection = new List();
      this.collection.bind(&apos;add&apos;, this.appendItem); // collection event binder

      this.counter = 0;
      this.render();
    },
    render: function(){
      var self = this;
      $(this.el).append(&quot;&lt;button id=&apos;add&apos;&gt;Add list item&lt;/button&gt;&quot;);
      $(this.el).append(&quot;&lt;ul&gt;&lt;/ul&gt;&quot;);
      _(this.collection.models).each(function(item){ // in case collection is not empty
        self.appendItem(item);
      }, this);
    },
    addItem: function(){
      this.counter++;
      var item = new Item();
      item.set({
        part2: item.get(&apos;part2&apos;) + this.counter // modify item defaults
      });
      this.collection.add(item);
    },

    appendItem: function(item){
      var itemView = new ItemView({
        model: item
      });
      $(&apos;ul&apos;, this.el).append(itemView.render().el);
    }
  });

  var listView = new ListView();
})(jQuery);
</code></pre><h1 id="5-js-本例介绍两个新的模型动作（交换与删除）-说明这些动作应该如何在模型的视图中被处理。演示效果看这里。"><a href="#5-js-本例介绍两个新的模型动作（交换与删除）-说明这些动作应该如何在模型的视图中被处理。演示效果看这里。" class="headerlink" title="5.js  本例介绍两个新的模型动作（交换与删除） 说明这些动作应该如何在模型的视图中被处理。演示效果看这里。"></a>5.js  本例介绍两个新的模型动作（交换与删除） 说明这些动作应该如何在模型的视图中被处理。演示效果看<a href="/src/demos/hello5.html">这里</a>。</h1><p>Backbone.sync：使用匿名函数重载持久化存储。这个属性允许在不抛出异常信息的前提下使用 Model.destroy()。</p>
<p>ItemViews 对于每个条目响应两个点击动作，交换与删除。</p>
<p>initialize() 绑定模型更改与删除到适当的事件。</p>
<p>render() 包含两个额外的span以响应交换与删除事件。</p>
<p>unrender()：让模型从DOM中移除它自己。</p>
<p>swap() 会在内部交换条目的属性，当.set()模型函数被调用，事务更新将会被触发。</p>
<p>remove()：我们使用destroy()方法从集合中移除模型。通常这也会从持久存储中删除记录，但是我们重载了它（参考以上例子）。</p>
<pre><code>(function($){

  Backbone.sync = function(method, model, success, error){
    success();
  }
  var Item = Backbone.Model.extend({
    defaults: {
      part1: &apos;hello&apos;,
      part2: &apos;world&apos;
    }
  });

  var List = Backbone.Collection.extend({
    model: Item
  });

  var ItemView = Backbone.View.extend({
    tagName: &apos;li&apos;, // name of tag to be created

    events: {
      &apos;click span.swap&apos;:  &apos;swap&apos;,
      &apos;click span.delete&apos;: &apos;remove&apos;
    },

    initialize: function(){
      _.bindAll(this, &apos;render&apos;, &apos;unrender&apos;, &apos;swap&apos;, &apos;remove&apos;); // every function that uses &apos;this&apos; as the current object should be in here

      this.model.bind(&apos;change&apos;, this.render);
      this.model.bind(&apos;remove&apos;, this.unrender);
    },

    render: function(){
      $(this.el).html(&apos;&lt;span style=&quot;color:black;&quot;&gt;&apos;+this.model.get(&apos;part1&apos;)+&apos; &apos;+this.model.get(&apos;part2&apos;)+&apos;&lt;/span&gt; &amp;nbsp; &amp;nbsp; &lt;span class=&quot;swap&quot; style=&quot;color:blue;&quot;&gt;[swap]&lt;/span&gt; &lt;span class=&quot;delete&quot; style=&quot;color:red;&quot;&gt;[delete]&lt;/span&gt;&apos;);
      return this; // for chainable calls, like .render().el
    },

    unrender: function(){
      $(this.el).remove();
    },

    swap: function(){
      var swapped = {
        part1: this.model.get(&apos;part2&apos;),
        part2: this.model.get(&apos;part1&apos;)
      };
      this.model.set(swapped);
    },

    remove: function(){
      this.model.destroy();
    }
  });

  var ListView = Backbone.View.extend({
    el: $(&apos;body&apos;), // el attaches to existing element
    events: {
      &apos;click button#add&apos;: &apos;addItem&apos;
    },
    initialize: function(){
      _.bindAll(this, &apos;render&apos;, &apos;addItem&apos;, &apos;appendItem&apos;); // every function that uses &apos;this&apos; as the current object should be in here

      this.collection = new List();
      this.collection.bind(&apos;add&apos;, this.appendItem); // collection event binder

      this.counter = 0;
      this.render();
    },
    render: function(){
      var self = this;
      $(this.el).append(&quot;&lt;button id=&apos;add&apos;&gt;Add list item&lt;/button&gt;&quot;);
      $(this.el).append(&quot;&lt;ul&gt;&lt;/ul&gt;&quot;);
      _(this.collection.models).each(function(item){ // in case collection is not empty
        self.appendItem(item);
      }, this);
    },
    addItem: function(){
      this.counter++;
      var item = new Item();
      item.set({
        part2: item.get(&apos;part2&apos;) + this.counter // modify item defaults
      });
      this.collection.add(item);
    },
    appendItem: function(item){
      var itemView = new ItemView({
        model: item
      });
      $(&apos;ul&apos;, this.el).append(itemView.render().el);
    }
  });

  var listView = new ListView();
})(jQuery);
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-15-the-view-of-backbone/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-15-the-view-of-backbone/" itemprop="url">Backbone中的View</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-15-the-view-of-backbone/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-15-the-view-of-backbone/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="/src/demos/view.html">本页demo</a></p>
<p>View是backbone中重要的一环。第一个程序注定是从hello world开始。在开始之前，先创建一个HTML文件，在其中引用这三个JS库（注意：underscore要在backbone前面）：</p>
<pre><code>jquery.js
underscore.js
backbone.js
</code></pre><p>页面的内容就随意了，下面的例子要求页面中包含一个<div id="body">节点。<br>然后创建一个最简单的View：</div></p>
<pre><code>var TestView = Backbone.View.extend({  //  创建一个view，其实就是一个HTML的DOM节点
    initialize: function() {
        this.render();
    },
    render: function() {  // 渲染方法
        this.$el.html(&apos;Hello World&apos;);  //  this.el就是HTML节点，通过jQuery的html方法填充内容
        return this;
    }
});

$(function () {
    var v = new TestView({el: $(&apos;#body&apos;)});  //  以目标节点（一个 &lt;div id=&quot;body&quot; /&gt;）为el参数，创建一个view的实例，render函数将会被自动调用并将渲染结果填充到el中
    //v.render(); // 如果没在 initialize 里调用 render 的话，就需要在这里调用一次
});
</code></pre><h1 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h1><p>试一个简单的效果：点击隐藏。把上面的View改成这样：</p>
<pre><code>var TestView = Backbone.View.extend({
    events: {
        &apos;click button#toggle&apos; : &apos;toggle&apos; //  响应toggle button的click事件
    },
    initialize: function() {
        this.render();
    },
    render: function() {
        this.$el.html(&apos;&lt;p id=&quot;hello&quot;&gt;Hello World&lt;/p&gt;&lt;button id=&quot;toggle&quot;&gt;Toggle&lt;/button&gt;&apos;);  //  增加一个toggle button
        return this;
    },
    toggle: function() {
        $(&quot;#hello&quot;).toggle();  //  用jQuery的toggle方法切换显示
        return this;
    }
});
</code></pre><p>注意，如果 events 里用的是非唯一的绑定，可以通过以下方式取得发生事件的对象：<br>    // …<br>    ‘click button.show’: ‘showItem’<br>    // …<br>    showItem: function (e) {<br>      alert($(e.currentTarget));<br>    }</p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>代码里嵌入HTML是很麻烦的事情，所以模板是需要的。理论上可以在backbone里使用任何JavaScript模板，这里以underscore自带的template为例。先按模板的语法在HTML文件里写一个模板：</p>
<pre><code>&lt;script type=&quot;text/template&quot; id=&quot;hello-template&quot;&gt;
    &lt;div&gt;
        &lt;h3 id=&quot;hello&quot;&gt;${message}&lt;/h3&gt;
        &lt;button id=&quot;toggle&quot;&gt;Toggle&lt;/button&gt;
    &lt;/div&gt;
&lt;/script&gt;
</code></pre><p>为了不影响页面的正常显示，JS模板通常都是放在 text/template 类型的 script 标签里。<br>注意，因为习惯的问题，模板里的变量标记没有使用默认的&lt;%= %&gt;，而是改成和python mako里一样的 ${ }，为此需要修改underscore的模板设置如下：</p>
<pre><code>_.templateSettings = {
   interpolate : /\$\{(.+?)\}/g
};
</code></pre><p>而显示模板的方法如下：</p>
<pre><code>var TestView = Backbone.View.extend({
    template: null,  //  把模板直接放这里有时也可以，但有时又会出错，还不知道是什么原因
    events: {
        &apos;click button#toggle&apos; : &apos;toggle&apos;
    },
    initialize: function() {
        this.template = _.template($(&quot;#hello-template&quot;).html());  //  模板放这里一般没问题
        this.render();
    },
    render: function() {
        this.$el.html(this.template({message: &quot;hello world!&quot;}));  //  渲染模板
        return this;
    },
    toggle: function() {
        this.$(&quot;#hello&quot;).toggle();
        return this;
    }
});
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-17-js-douhao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-17-js-douhao/" itemprop="url">JS逗号运算符的用法详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-17-js-douhao/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-17-js-douhao/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>需要明白的概念：</p>
<p><strong>表达式</strong>，所谓的表达式就是—— 一个JavaScript的“短语“，JavaScript的解释器可以计算它，从而生成一个值。表达式可以分为以下三种：</p>
<ol>
<li><p><strong>直接量</strong>。如1.7是数字直接量、”JavaScript权威指南”是一个字符串直接量等。</p>
</li>
<li><p><strong>变量</strong>。直接量表达式的值就是这个直接量本身，变量表达式的值则是该变量所存放或引用的值。</p>
</li>
<li><p>可以“合并”上面提到的“简单”表达式来创建为比较<strong>复杂的表达式</strong>。例如1.7是表达式，i也是表达式，下面的代码所示的同样也是（也可以叫）表达式：i + 1.7。</p>
</li>
</ol>
<p>上面这个表达式的值是两个简单表达式（一个变量表达式和一个简单表达式）的和。在此例中，“+”是一个运算符，用于将两个简单表达式合并起来以组成一个复杂的表达式。</p>
<p><strong>运算数的个数</strong></p>
<p>可以根据运算符需要的运算数的个数对运算符进行分类，大多数运算符都是二元运算符，它们把两个“表达式”合并成一个复杂的表达式。简而言之，就是它有两个运算数。此外，JavaScript还支持大量的一元运算符，它能将一个表达式转换成另一个更复杂的表达式。如表达式-3中，运算符“－”就是一元运算符，它执行操作是对运算数取反。</p>
<p>JavaScript还支持三元操作符“？：”，它可以将三个表达式合并为一个复杂的表达式。</p>
<p>OK，下面开始讲解逗号运算符。</p>
<p><strong>逗号运算符，它将先计算左边的参数，再计算右边的参数值。然后返回最右边参数的值。</strong></p>
<pre><code>var a = 10, b = 20;

function CommaTest(){
return a++, b++, 10;
}

var c = CommaTest();

alert(a); // 返回11
alert(b); // 返回21
alert(c); // 返回10
</code></pre><p>变量c的值是函数CommaTest返回的值，而a和b多加1了。</p>
<p>逗号运算符和函数调用运算符的冲突</p>
<p>在JavaScript中，函数调用确实是函数调用运算符。它很特殊，因为其它编程语言资料中多从来没有这个叫法的。然后，（才是）它没有固定数目的运算数。</p>
<p>函数调用运算符的第一个参数是一个函数名或者是一个引用函数的表达式，其后是括号（）。括号中间可以是数目不定的运算符，这些运算数可以是任意的表达式，它们之间用逗号隔开。</p>
<p>函数调用运算符将计算它的每一个运算数，第一个运算数指定为函数名（括号前），而括号中间的所有运算数的值将传递给这个函数作为函数的参数。</p>
<p>例如：</p>
<pre><code>document.close()
Math.sin(x)
alert(&quot;Welcome &quot; + name)
Date.UTC(2000, 11, 31, 23, 59, 59)
funcs.f(funcs.args[0], funcs.args[1])
</code></pre><p>知道了调用函数运算符后，我们举个例子说明关于如何处理它们冲突的事。</p>
<pre><code>alert(2*5, 2*4); // 输出10
</code></pre><p>上面这段代码输出10,但是如果根据逗号运算符的原理来解释的话，那应该是输出8才对。为什么呢？</p>
<p><strong>因为逗号运算符在JavaScript在的优先级是最底的</strong>，记住这一点非常有用。<strong>所以函数调用运算符将先于逗号运算符运行</strong>。结果alert函数输出第一个参数的值。将上面的代码修改成如下所示即可。</p>
<pre><code>alert((2*5, 2*4)); // 返回8
</code></pre><p>逗号运算符和赋值运算赋的冲突</p>
<p>在JavaScript中，逗号运算符的优先级比赋值运算符还要底。请看下面的代码。</p>
<pre><code>var a = 20;
var b = ++a,10;
alert(b); //语法错误
</code></pre><p>这段代码似乎不能运行，可能是由于赋值运算符优先于逗号表达式运行，如果将代码改成如下即可了。</p>
<pre><code>var a = 20;
var b = (++a,10);
alert(b);
</code></pre><p>逗号运算符要求它的运算数是一个复杂的表达式或简单的表达式（如变量或直接量），但由于赋值运算符优先于逗号运算符执行，因此变成左边不是一个运算数或一个表达式，而是一个含有var关键字的语句</p>
<p>之前不能执行的代码可以看成如下代码：</p>
<pre><code>var a = 20;
(var b = ++a),10;
alert(b);
</code></pre><p>语句中有表达式语句，但不是所有的语句都是表达式。</p>
<hr>
<p>一、逗号运算符的特性及作用 </p>
<p>逗号运算符的作用是将若干表达式连接起来。它的优先级别在所有运算符中是最低的，结合方向是”自左至右”的。<br>如：3<em>3，4</em>4</p>
<p>二、逗号表达式</p>
<p>逗号表达式的一般形式是：表达式1，表达式2，表达式3……表达式n</p>
<p>逗号表达式的求解过程是：先计算表达式1的值，再计算表达式2的值，……一直计算到表达式n的值。最后整个逗号表达式的值是表达式n的值。</p>
<p>看下面几个例子：</p>
<pre><code>x=8*2,x*4        /*整个表达式的值为64，x的值为16*/ 
(x=8*2,x*4),x*2  /*整个表达式的值为128，x的值为16*/ 
x=(z=5,5*2)      /*整个表达式为赋值表达式，它的值为10，z的值为5*/ 
x=z=5,5*2        /*整个表达式为逗号表达式，它的值为10，x和z的值都为5*/
</code></pre><p>逗号表达式用的地方不太多，一般情况是在给循环变量赋初值时才用得到。所以程序中并不是所有的逗号都要看成逗号运算符，尤其是在函数调用时，各个参数是用逗号隔开的，这时逗号就不是逗号运算符。<br>如：printf(“%d,%d,%d”,x,y,z); </p>
<hr>
<p>运算符使它两边的表达式以从左到右的顺序被执行，并获得右边表达式的值。’,’运算符最普通的用途是在 for 循环的递增表达式中使用。例如：</p>
<pre><code>for (i = 0; i &lt; 10; i++, j++){
  k = i + j;
}
</code></pre><p>每次通过循环的末端时， for 语句只允许单个表达式被执行。’,’运算符被用来允许多个表达式被当作单个表达式，从而规避该限制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-15-user-backbone/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-15-user-backbone/" itemprop="url">使用Backbone</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-15-user-backbone/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-15-user-backbone/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="/src/demos/use-backbone.html">本文代码demo</a></p>
<p>随着JavaScript程序变得越来越复杂，往往需要一个团队协作开发，这时代码的模块化和组织规范就变得异常重要了。MVC模式就是代码组织的经典模式。backbone.js就是为前端开发提供MVC模式滴！</p>
<p>backebone.js官网介绍<br><a href="http://backbonejs.org/" target="_blank" rel="external">官方网站</a> ，中文手册可以看 <a href="http://www.css88.com/doc/backbone/" target="_blank" rel="external">这里</a>。</p>
<p>官网上面明确指出Backbone.js依赖 <a href="http://underscorejs.org/" target="_blank" rel="external">Underscore.js</a> ,中文手册看 <a href="http://learningcn.com/underscore/" target="_blank" rel="external">这里</a> ，所以在使用backbone.js的时候，必须引入underscore.js。官网也提供了 <a href="http://backbonejs.org/docs/backbone.html" target="_blank" rel="external">查看源码</a> 的地址，文档注释写的非常详细。另外在官网上面都会给出代码示例，在代码的右上角上，有一个运行的按钮，点击的运行就可以看到这段代码运行的结果啦。</p>
<p>官网左侧菜单栏里面就是backbone.js的全部模块了</p>
<p>Events 事件：backbone.js是事件驱动的，可以给对象绑定自定义事件</p>
<p>Model 模型：MVC中的M，对数据的操作都在这里了</p>
<p>Collection 集合：是Model的集合</p>
<p>Router 路由：为客户端路由提供支持，并支持旧浏览器</p>
<p>History 历史：处理hashchange或pushState</p>
<p>Sync 同步：向服务器进行同步，默认同步方式调用的是jQuery.ajax，可以重写Sync修改为其他同步方式</p>
<p>View 视图：含事件行为和渲染页面</p>
<p>Utility 工具：为解决冲突提供工具</p>
<p>F.A.O 问答：常见问答</p>
<p>Examples 案例：backbone.js有很多案例，直接点击就可以查看了</p>
<p>MVC</p>
<ul>
<li><p>（1）<strong>Model</strong>  Model表示数据层，也就是程序需要的数据源，通常使用JSON格式表示。</p>
</li>
<li><p>（2）<strong>View</strong>  View表示表现层，也就是用户界面，对于网页来说，就是用户看到的网页HTML代码。</p>
</li>
<li><p>（3）<strong>Controller</strong>  Controller表示控制层，用来对原始数据（Model）进行加工，传送到View。</p>
</li>
</ul>
<p>由于网页编程不同于客户端编程，在MVC的基础上，JavaScript社区产生了各种变体框架MVP（Model-View-Presenter）、MVVM（Model-View-ViewModel）等等，有人就把所有这一类框架的各种模式统称为MV*。</p>
<p>框架的优点在于合理组织代码、便于团队合作和未来的维护，缺点在于有一定的学习成本，且限制你只能采取它的写法。</p>
<p>backbone.js主要内容介绍<br>Model.constructor</p>
<pre><code>var tom = new Backbone.Model({&apos;name&apos;:&apos;tom&apos;});  // 创建学生tom
var peter = new Backbone.Model({&apos;name&apos;:&apos;peter&apos;}); // 创建学生peter

var students = new Backbone.Collection(); // tom和peter都是学生
students.add( tom );    // 向Collection中添加学生
students.add( peter );

console.log( JSON.stringify(students) ); //[{&quot;name&quot;:&quot;tom&quot;},{&quot;name&quot;:&quot;peter&quot;}]
</code></pre><p>通过new的方式创建了两个Model的实例；通过json对象的传参方式给Model的constuctor构造函数传递了name属性。</p>
<p>通过new的方式创建了一个Collection实例；通过调用students的add方法，将tom和peter添加到集合中。</p>
<p>通过 文档 可以看出，通过{‘name’:’tom’}这种方式给Model设置的属性，实际上会调用model.set()方法。</p>
<p>Model.extend</p>
<pre><code>var User = Backbone.Model.extend({
sayHello : function(){  //实例方法
  console.log(&quot;hello&quot;);
    }
},
{
sayWorld : function(){  //静态方法
  console.log(&quot;world&quot;);
    }
});
var tom = new User; // 创建一个用户
tom.sayHello(); // 调用用户的实例方法
User.sayWorld(); // 直接调用Model的静态方法
</code></pre><p>通过extend扩展了Backbone.Model，第一个参数是实例对象中的属性，第二个可选的参数会直接注册到构造函数成为静态方法。这样即使没有实例化对象，也能调用Model中定义的方法</p>
<pre><code>var User = Backbone.Model.extend({
  defaults : {    // 默认属性，但是子类也会继承
    &quot;name&quot;: &quot;tom&quot;
  },
  sayHello : function(){  // 父类的方法
    console.log(&quot;hello&quot;);
  }
});
var ChildUser = User.extend({   // ChildUser 继承自User
  sayChild : function(){  // 子类的方法
    console.log(&quot;child&quot;);
  }
});
var child = new ChildUser;  // 创建ChildUser实例
child.sayHello();    // 子类继承父类sayHello()方法
child.sayChild();    // 子类自己的方法
console.log(child.get(&quot;name&quot;));  // 子类继承父类属性
</code></pre><p>extend会正确的设置原型链，所以可以通过extend实现继承。上面的代码就是创建父类User，然后子类ChildUser继承子父类。子类会继承父类的属性、方法</p>
<p>Model.initialize</p>
<pre><code>var User = Backbone.Model.extend({
  defaults : {
    name : &apos;tom&apos;  // 默认的名字
  },
  initialize : function(){  //当model创建的时候，调用
    console.log(&quot;initialize&quot;);
    this.on(&apos;change&apos;,function(){  // 当数据发生变化的时候触发
      console.log(&quot;此时我的名字是：&quot;+this.get(&quot;name&quot;));
    });
  }
});
var tom = new User;
tom.set(&apos;name&apos;,&apos;jack&apos;); // 修改模型的数据，会被change检测到
</code></pre><p>如果指定了initialize方法，会在创建实例对象之后调用。当修改了模型数据，会触发自定义事件。</p>
<pre><code>var User = Backbone.Model.extend({
  defaults : {
    name : &apos;tom&apos;,   // 默认的名字
    age : 10
  },
  initialize : function(){  //当model创建的时候，调用
    console.log(&quot;initialize&quot;);  
    this.on(&apos;change:name&apos;,function(){   // 只检测name的变化
      console.log(&quot;此时我的名字是：&quot;+this.get(&quot;name&quot;));
    });
  }
});
var tom = new User;
tom.set(&apos;name&apos;,&apos;jack&apos;); // 修改模型的数据，会被change检测到
tom.set(&apos;age&apos;,&apos;20&apos;);// 修改年龄不会被change检测
</code></pre><p>如果只想检测某个属性的变化，可以通过添加命名空间的方式区别开事件。</p>
<p>listenTo、View initialize</p>
<pre><code>$(function(){
  var User = Backbone.Model.extend({
    defaults : {
      name : &apos;tom&apos;
    }
  });
  var View = Backbone.View.extend({
    initialize : function(){
      console.log(&quot;initialize&quot;);
      this.listenTo( this.model , &apos;change&apos; , this.show );  // 当与这个view绑定的model数据发生变化的时候，调用show方法
    },
    show : function(model){ // 向页面中输出信息
      $(&apos;body&apos;).append( &apos;&lt;div&gt;&apos;+ this.model.get(&apos;name&apos;)+ &apos;&lt;/br&gt;也可以通过参数调用&lt;/br&gt;&apos; + model.get(&apos;name&apos;) +&apos;&lt;/div&gt;&apos; );
    }
  });
  var tom = new User;
  var view = new View({model:tom});    // 创建view实体
  setTimeout(function(){
    tom.set(&apos;name&apos;,&apos;jack&apos;);  // 修改数据
  }, 1000);    // 一秒后修改数据，触发show
});
</code></pre><p>listenTo允许一个对象监听另一个对象的事件，上面的代码就是让view监听model的change事件。</p>
<p>sync、Model.save()</p>
<pre><code>Backbone.sync = function(method, model) {
  console.log(method + &quot;: &quot; + JSON.stringify(model));
  model.set(&apos;id&apos;, 1);   // 模型的特殊属性
};
var Book = Backbone.Model.extend({
  defaults:{
    title: &quot;The Rough Riders&quot;,
    author: &quot;Theodore Roosevelt&quot;
  }
});
var b = new Book;
b.save();    // create: {&quot;title&quot;:&quot;The Rough Riders&quot;,&quot;author&quot;:&quot;Theodore Roosevelt&quot;}
b.save({author: &quot;Teddy&quot;}); // update: {&quot;title&quot;:&quot;The Rough Riders&quot;,&quot;author&quot;:&quot;Teddy&quot;,&quot;id&quot;:1}
</code></pre><p>调用模型的save方法，就是委托Backbone.sync对数据进行持久化处理（保存到数据库），如果验证成功返回jqXHR，否则返回false。sync默认情况下是使用的是jQuery.ajax，可以通过重写sync来使用其他方式进行持久化处理如WebSockets,XML,或者Local Storage。上面的代码就是重写Backbone.sync的过程。第一次save的时候发送的create请求，第二次save的时候发送的是update请求。Backbone是如何区分第一次请求还是第二次请求的呢？是根据通过model.isNew这个方法进行判断的。如果模型没有id属性，就是表示模型是新模型可以通过下面的代码测试</p>
<pre><code>Backbone.sync = function(method, model) {
  console.log(method + &quot;: &quot; + JSON.stringify(model));
  console.log(model.isNew());   // 此时不存在id属性，所以是true
  model.set(&apos;id&apos;, 1);   // 模型的特殊属性
  console.log(model.isNew()); // 此时存在id属性，所以是false
};
</code></pre><p>在 Model.id文档中指出，如果通过set设置了model的id，就会将这个id拷贝到模型上，作为model的直接属性。在下图中可以发现通过Model.set(‘id’,1)，给attributes中添加了id属性，也直接给model添加了id属性。</p>
<p>但是相反的，如果通过model.id=1的方式直接给model添加id属性，是不会拷贝到attributes中的。如果只是给model直接添加了id，通过Model.isNew返回的一直都会是true。</p>
<pre><code>Backbone.sync = function(method, model) {
  console.log(method + &quot;: &quot; + JSON.stringify(model));
  console.log(model.isNew());   // 返回true
  model.id=1;   // 给model直接添加id属性
  console.log(model.isNew()); // 返回true
};
</code></pre><p>View和Events</p>
<pre><code>var BodyView = Backbone.View.extend({
  el : $(&apos;body&apos;), // 如果没有指定el，el就会是个空div
  events : {
    &apos;click input&apos; : &apos;sayHello&apos;, // 点击input的时候调用sayHello方法
    &apos;mouseover li&apos; : &apos;moveLi&apos;// 鼠标悬浮li标签的时候调用moveLi方法
  },
  sayHello : function(){
    console.log(&quot;Hello&quot;);
  },
  moveLi : function(){
    console.log(&quot;mouseover li&quot;);
  }
});
var view = new BodyView;
</code></pre><p>如果设置了tagName、className、id、attributes属性（为视图知道根元素），那么view.el就会被创建，都在view.el就是个空的div。Backbone.events可以写成对象的形式，给视图绑定一组自定义事件。</p>
<p>template</p>
<pre><code>var Name = Backbone.Model.extend({
  defaults : {
    name : &apos;tom&apos;
  }
});
var NameView = Backbone.View.extend({
  initialize : function(){
    this.listenTo( this.model , &apos;change&apos; , this.showName );
  },
  showName : function(model){
    // $(&apos;body&apos;).append( &quot;&lt;div&gt;&quot; + model.get(&quot;name&quot;) + &quot;&lt;/div&gt;&quot; );    // 不使用template的时候html代码与js写在一起
    $(&apos;body&apos;).append( this.template(this.model.toJSON()) );
    // 使用模版之后，html代码与js代码相分离
  },
  template: _.template($(&apos;#name&apos;).html())
  // _.template中传入需要编译的模版
  // 返回的结果就是编译后的html代码
  // 最后在showName中调用，将编译后的html显示到body中
});
var name = new Name;
var nameView = new NameView({model:name});
name.set(&apos;name&apos;,&apos;jack&apos;);
&lt;script type=&quot;text/template&quot; id=&quot;name&quot;&gt;
  &lt;% for (var i=0;i&lt;5;i++) { %&gt;
    &lt;div&gt;&lt;%= name %&gt;&lt;/div&gt;
  &lt;% } %&gt;
&lt;/script&gt;
</code></pre><p>使用js模版不仅可以将html代码和js代码分离，提高可读性，也能提高开发效率。backbone.js使用的underscore.js中的template</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://flyingliu.github.io/2015/11/15/2015-09-17-javascript-asi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="飞来小侠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如是我闻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/15/2015-09-17-javascript-asi/" itemprop="url">趣谈 JavaScript 中的 ASI (Automatic Semicolon Insertion)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-15T16:37:02+08:00">
                2015-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/11/15/2015-09-17-javascript-asi/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/11/15/2015-09-17-javascript-asi/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自动分号插入 (automatic semicolon insertion, ASI) 是一种程序解析技术，它在 JavaScript 程序的语法分析 (parsing) 阶段起作用。</p>
<p>根据 ES2015 规范，某些（不是全部） JavaScript 语句需要用 ; 来表示语句的结束；然而为了方便书写，在某些情况下这些分号是可以从源码中省略的，此时我们称 ; 被 parser 自动插入到符号流 (token stream) 中，这种机制称为 ASI。</p>
<p>所谓的“自动分号插入”其实只是一种形象的描述，parser 并没有真的插入一个个分号。ASI 只是表示编译器正确理解了程序员的意图。听起来就像编译器对程序员说：“Hey，哥们！虽然这里你没写分号，但我知道你想说这条语句已经结束了。”</p>
<p>需要用 ; 来表示结束的语句是：</p>
<ul>
<li>空语句</li>
<li>以 let 、 const 、import 、 export 开头的声明语句</li>
<li>以 var 开头的变量声明语句</li>
<li>表达式语句</li>
<li>debugger 语句</li>
<li>continue 语句</li>
<li>break 语句</li>
<li>return 语句</li>
<li>throw 语句</li>
</ul>
<p>并不是所有的 JavaScript 语句都需要用 ; 表示结束，例如：</p>
<ul>
<li>块语句</li>
<li>if 语句</li>
<li>try 语句</li>
<li>这些语句本来就不需要 ; 表示结束。</li>
</ul>
<p>举例来说，函数声明 (Function declaration, FD) 不需要以分号结束：</p>
<pre><code>function add10(num) {
    return num + 10;
} // I don&apos;t need a semicolon here
</code></pre><p>如果你画蛇添足地在 FD 之后写了一个 ;，它会被解析为一条空语句。</p>
<p>ASI 规则</p>
<p>ASI 是备胎（第二选择）</p>
<p>编译器不会优先启用 ASI 机制。实际上，在遇到行结束符 (Line Terminator) 时，编译器总是先试图将行结束符分隔的符号流当作一条语句来解析（其实有少数几个特例：return、throw、break、continue、yield 、++ 、 –，随后会介绍），实在不符合正确语法的情况下，才会退而求其次，启用 ASI 机制，将行结束符分隔的符号流当作两条语句（俗称，插入分号）。来看下面的例子：</p>
<pre><code>var a = 0
var b = 1
</code></pre><p>这个简单代码段的符号流为：</p>
<pre><code>var   a   =   0   \n   var   b   =   1
</code></pre><p>parser 从左至右解析这个符号流，解析过程中它遇到了换行符 LF ( \n , 行结束符之一)。它看起来这样自言自语：“我遇到了一个换行符，让我先试试去掉它，把这个代码段当作一条语句试试！”</p>
<p>于是 parser 实际上先解析了这样一条语句：</p>
<pre><code>var a = 0 var b = 1
// Uncaught SyntaxError: Unexpected token var
</code></pre><p>很显然这是一条有语法错误的语句，此路不通！</p>
<p>parser 说：“这个符号流如果当作一条语句的话，是有语法错误的！这该怎么办呢？我是不是要就此放弃、直接抛出语法错误呢？不！我可是要成为海贼王的男人！我要启用 ASI 机制试试。”</p>
<p>于是不折不挠的 parser 又解析了下面的语句：</p>
<pre><code>var a = 0; var b = 1     // legal syntax
</code></pre><p>Bingo! 没有 SyntaxError ，解析通过！</p>
<p>parser 于是得意地对程序员说：“Hey，哥们！虽然在 \n 前面你没写分号，但我知道你想说 var a = 0 这条赋值语句已经结束了！”</p>
<p>“高！实在是高！”</p>
<p>脆弱的符号、被误解的源码</p>
<p>需要注意的是，parser 对符号流的这种处理机制有时会导致它误解程序员的意图。</p>
<pre><code>var a = [1, [2, 3]]
[3, 2, 1].map(function(num) {
    return num * num;
</code></pre><p>})<br>由于 parser 总是优先将换行符前后的符号流当作一条语句解析，parser 实际上先解析了下面的语句：</p>
<pre><code>var a = [1, [2, 3]][3, 2, 1].map(function(num) {
    return num * num;
})
</code></pre><p>这是一条语法正确的语句。它的含义是：先声明变量a ，对 [1, [2, 3]][3, 2, 1] 求值之后得到数组 [2, 3] ，对 [2, 3] 进行 (num) =&gt; num * num 映射操作得到 [4, 9]，将数组 [4, 9] 赋给变量 a 。</p>
<p>以 ( 开始的语句，比如 IIFE ，也会导致程序被 parser 误解。</p>
<pre><code>(function fn() {
    return fn;
})()
(function() {
    console.log(&apos;我会显示在控制台吗？&apos;);
})()
</code></pre><p>它等价于</p>
<p>// 一条函数连续调用语句<br>(function fn() {<br>    return fn;<br>})()(function() {<br>    console.log(‘我会显示在控制台吗？’);<br>})()  // =&gt; fn<br>以 / 开始的语句，通常是正则表达式放在语句起始处（这种情况比较少见），也会导致程序被 parser 误解。</p>
<p>var a = 2<br>/error/i.test(‘error’)<br>它等价于</p>
<p>var a = 2 / error / i.test(‘error’)<br>// =&gt; Uncaught ReferenceError: error is not defined<br>需要注意的是，虽然 var a = 2 / error / i.test(‘error’) 会抛出 ReferenceError 异常，但它是一条没有语法错误 (SyntaxError) 的语句。换句话说，该语句在 parser 眼里是一条语法正确的语句，因此 parser 不会启用 ASI 机制。</p>
<p>语句起始处的 + 和 - 也会导致源码被误解（更加少见）。</p>
<p>var num = 5<br>+new Date - new Date(2009, 10)<br>等价于</p>
<p>var num = 5 + new Date - new Date(2009, 10)</p>
<p>源码的意图被 parser 误解，有两个必要条件：</p>
<p>parser 优先将行结束符前后的符号流按一条语句解析，这是 ECMAScript 标准的规定，所有 parser 必须要按此要求实现。<br>行结束符之后的符号 (token) 有二义性，使得该符号与上条语句能够无缝对接，不导致语法错误。<br>实际上，有二义性的符号本来就不多，能导致源码意图被改变的符号数来数去就只有 [ 、( 、/ 、+ 、- 这五个而已。我们可以把它们理解成“脆弱的符号”，在它们前面显式地加上防御性分号 (defensive semicolon) 来保护其含义不被改变。</p>
<p>限制产生式——备胎转正</p>
<p>前文说到，ASI 是一种备用选择。然而在 ECMAScript 中，有几种特殊语句是不允许行结束符存在的。如果语句中有行结束符，parser 会优先认为行结束符表示的是语句的结束，这在 ECMAScript 标准中称为限制产生式 (restricted production)。</p>
<p>通俗地说，在限制产生式中，parser 优先启用 ASI 机制。</p>
<p>一个典型限制产生式的例子是 return 语句。</p>
<pre><code>function a() {
    return
    {};
}
a()   // =&gt; undefined
</code></pre><p>按照一般解析规则，如果 ASI 是第二选择，那么 parser 优先忽略 \n ，该代码段应与下面的程序无异：</p>
<pre><code>function a() {
    return {};
}
a()  // =&gt; {} (empty object)
</code></pre><p>然而事实并非如此，因为 ECMAScript 标准对合法的 return 语句做了如下限制：</p>
<p>ReturnStatement:<br>return [no LineTerminator here] Expression ;<br>return 语句中是不允许在 return 关键字之后出现行结束符的，所以上面的代码段其实等价于：</p>
<pre><code>function a() {
    return;    // ReturnStatement
    {}         // BlockStatement
    ;          // EmptyStatement
}
a()  // =&gt; undefined
</code></pre><p>函数体内的代码被解析为 return 语句、块语句、空语句三条单独的语句。</p>
<p>标准规定的其它限制产生式有：</p>
<ul>
<li>continue 语句</li>
<li>break 语句</li>
<li>throw 语句</li>
<li>箭头函数 （箭头左侧不允许有行结束符）</li>
<li>yield 表达式</li>
<li>后自增/自减表达式</li>
<li><p>这些情况都不允许有换行符存在。</p>
<p>  a<br>  ++<br>  b</p>
</li>
</ul>
<p>被解析为</p>
<pre><code>a;
++b;
</code></pre><p>ES2015 标准给出了关于限制产生式的编程建议：</p>
<blockquote>
<p>A postfix ++ or – operator should appear on the same line as its operand. （后自增运算符或后自减运算符应与它的操作数处于同一行。）<br>  An Expression in a return or throw statement or an AssignmentExpression in a yield expression should start on the same line as the return, throw, or yield token. （return 或 throw 语句中的表达式以及 yield 表达式中的赋值表达式应与 return 、throw 、yield 这些关键字处于同一行。）<br>An IdentifierReference in a break or continue statement should be on the same line as the break or continue token. （break 或 continue 语句中的标签名应与 break 或 continue 关键字处于同一行。）<br>言而总之，总而言之，ES2015 标准这一节就告诉你一件事：在限制生产式中别换行，换行就自动插入分号。</p>
</blockquote>
<p>for 循环与空语句——永不使用的备胎</p>
<p>ASI 不适用于 for 循环头部，即 parser 不会在这里自动插入分号。</p>
<pre><code>var a = [&apos;once&apos;, &apos;a&apos;, &apos;rebound,&apos;, &apos;always&apos;, &apos;a&apos;, &apos;rebound.&apos;]
var msg = &apos;&apos;
for (var i = 0, len = a.length
    i &lt; len
    i++) {
    msg += a[i] + &apos; &apos;
}
console.log(msg)
</code></pre><p>好吧，也许你希望 parser 在 a.length 后面和 i &lt; len 后面自动为你插入分号，补全这个 for 循环语句，但是 parser 不会在 for 循环的头部启用 ASI 机制。parser 首先尝试按一条语句解析</p>
<p>(var i = 0, len = a.length \n i &lt; len \n i++)<br>这个符号流，发现它并非一条合法语句后，就直接抛出了语法错误 Uncaught SyntaxError: Unexpected Identifier，根本不尝试补全分号。</p>
<p>所以 for 循环头部的分号必须要显式地写出：</p>
<pre><code>var a = [&apos;once&apos;, &apos;a&apos;, &apos;rebound,&apos;, &apos;always&apos;, &apos;a&apos;, &apos;rebound.&apos;]
var msg = &apos;&apos;
for (var i = 0, len = a.length;
i &lt; len;
i++) {
msg += a[i] + &apos; &apos;
}
console.log(msg)
// =&gt; &apos;once a rebound, always a rebound.&apos; （一朝为备胎，永久为备胎）
</code></pre><p>类似地，有特殊含义的空语句也不可以省略分号：</p>
<pre><code>function infiniteLoop() {
    while(&apos;a rebound is a rebound is a rebound&apos;)
}
</code></pre><p>此段代码是不合法的语句，parser 会抛出语法错误 Uncaught SyntaxError: Unexpected token } 。这是因为循环体中作为空语句而存在的 ; 不能省略。</p>
<pre><code>// legal syntax
function infiniteLoop() {
    while(&apos;a rebound is a rebound is a rebound&apos;);
}
// it is true that a rebound is a rebound is a rebound （备胎就是备胎，这是真理。）
</code></pre><p>总结</p>
<p>ASI 机制的存在为 JavaScript 程序员提供了一种选择：你可以省略源码中的绝大部分 ; 而不影响程序的正确解析。与 IT 业界的 “Vim 和 Emacs 哪个是更好的编辑器” 一样，JavaScript 社区隔一段时间就会出现“该不该写分号”这样的观点之争。本文并不是想证明哪种观点更好，而是关注 ASI 机制本身的一些有趣事实。即便是坚定的无分号党，也不得不承认，有些分号是不能省略的。这些不能省略的分号有：</p>
<ul>
<li>for 循环头部的分号</li>
<li>作为空语句存在的分号</li>
<li>以 5 个“脆弱符号”开头的语句之前的分号 （严格来讲，此处的分号不是必须的；因为除了使用分号，还可以用各种 hack 方法，比如 void）</li>
</ul>
<p>而对于坚定的分号党，有一个事实也不得不承认，那就是你的程序中很可能有 99% 的分号都是多余的！如果你想尝试一下不写分号，可以按照下面的步骤：</p>
<ul>
<li>删掉你所有语句结尾处的分号</li>
<li>如果你的语句开头是 [ 或 (，在它前面加一个分号。Over!</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="飞来小侠" />
          <p class="site-author-name" itemprop="name">飞来小侠</p>
           
              <p class="site-description motion-element" itemprop="description">依法不依人，依义不依语。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">58</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/flyingliu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/5872146656" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/guolaiwan/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      豆瓣
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/liu-fei-lai/activities" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">飞来小侠</span>

  
</div>


  <div class="powered-by">
    由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    主题 &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Pisces
    </a>
  </div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://ananfo.disqus.com/count.js" async></script>
    

    

  




	





  










  





  

  

  

  

  

  

</body>
</html>
